<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>NetCDF-C++: netCDF::NcVar Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="netcdf-50x50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NetCDF-C++
   &#160;<span id="projectnumber">4.3.1-developer</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>NetCDF&#160;Documentation</span></a></li>
      <li><a href="pages.html"><span>Navigation</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classnetCDF_1_1NcVar.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">netCDF::NcVar Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class represents a <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable.  
 <a href="classnetCDF_1_1NcVar.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="ncVar_8h_source.html">ncVar.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6fa17911a9f7ec09cc05e34bc4f63a39"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a6fa17911a9f7ec09cc05e34bc4f63a39">ChecksumMode</a> { <a class="el" href="classnetCDF_1_1NcVar.html#a6fa17911a9f7ec09cc05e34bc4f63a39afc8c54af8efa1a65beb0ec52ad0de4ed">nc_NOCHECKSUM</a> = NC_NOCHECKSUM, 
<a class="el" href="classnetCDF_1_1NcVar.html#a6fa17911a9f7ec09cc05e34bc4f63a39a2098bffc0ca08276e8252847cf3ec269">nc_FLETCHER32</a> = NC_FLETCHER32
 }<tr class="memdesc:a6fa17911a9f7ec09cc05e34bc4f63a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for checksum specification (see <a class="el" href="classnetCDF_1_1NcVar.html#a92b89cc33bd3ab564c023e5620c0f4db" title="Sets the checksum parameters of a variable. ">NcVar::setChecksum</a>, <a class="el" href="classnetCDF_1_1NcVar.html#a38b5f4f38dde165aebfe7e61d0f4e3c0" title="Gets the checksum parameters of the variable. ">NcVar::getChecksum</a>).  <a href="classnetCDF_1_1NcVar.html#a6fa17911a9f7ec09cc05e34bc4f63a39">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6fa17911a9f7ec09cc05e34bc4f63a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8425b2967665ab83f1e76abac2a76a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a1e8425b2967665ab83f1e76abac2a76a">ChunkMode</a> { <a class="el" href="classnetCDF_1_1NcVar.html#a1e8425b2967665ab83f1e76abac2a76aa19d35fac1f574de8f0036a43cc2cc32f">nc_CHUNKED</a> = NC_CHUNKED, 
<a class="el" href="classnetCDF_1_1NcVar.html#a1e8425b2967665ab83f1e76abac2a76aa254599ed4575a7b58af3880b9ff66d15">nc_CONTIGUOUS</a> = NC_CONTIGUOUS
 }<tr class="memdesc:a1e8425b2967665ab83f1e76abac2a76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for chunking specifications (see <a class="el" href="classnetCDF_1_1NcVar.html#a02d0550ce2b4874e27e443467801d5b0" title="Sets chunking parameters. ">NcVar::setChunking</a>, <a class="el" href="classnetCDF_1_1NcVar.html#a4b267cf0903e6bca4493c2e4360aed00" title="Gets the chunking parameters. ">NcVar::getChunkingParameters</a>).  <a href="classnetCDF_1_1NcVar.html#a1e8425b2967665ab83f1e76abac2a76a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1e8425b2967665ab83f1e76abac2a76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e882d6cc8aa698ef82b96e14eaa7a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad6e882d6cc8aa698ef82b96e14eaa7a9">EndianMode</a> { <a class="el" href="classnetCDF_1_1NcVar.html#ad6e882d6cc8aa698ef82b96e14eaa7a9aa2313d7f36e771ad255cbec9100a720c">nc_ENDIAN_NATIVE</a> = NC_ENDIAN_NATIVE, 
<a class="el" href="classnetCDF_1_1NcVar.html#ad6e882d6cc8aa698ef82b96e14eaa7a9ae0c178e332e7b749f5c60f301f5d666f">nc_ENDIAN_LITTLE</a> = NC_ENDIAN_LITTLE, 
<a class="el" href="classnetCDF_1_1NcVar.html#ad6e882d6cc8aa698ef82b96e14eaa7a9a8ce7fd59a740013d5b7472c8c88f1fbe">nc_ENDIAN_BIG</a> = NC_ENDIAN_BIG
 }<tr class="memdesc:ad6e882d6cc8aa698ef82b96e14eaa7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to specifying the endianess of the data, (see <a class="el" href="classnetCDF_1_1NcVar.html#a429f38087cc007c8d6f947e1b4fab41d" title="Sets the endianness of the variable. ">NcVar::setEndianness</a>, <a class="el" href="classnetCDF_1_1NcVar.html#a4b8f11bc557205faed4144ea57e9ba1a" title="Gets the endianness of the variable. ">NcVar::getEndianness</a>).  <a href="classnetCDF_1_1NcVar.html#ad6e882d6cc8aa698ef82b96e14eaa7a9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad6e882d6cc8aa698ef82b96e14eaa7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab4aa88742d17f4cba10346eaf53a9c98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ab4aa88742d17f4cba10346eaf53a9c98">NcVar</a> ()</td></tr>
<tr class="memdesc:ab4aa88742d17f4cba10346eaf53a9c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor generates a <a class="el" href="classnetCDF_1_1NcVar.html#abff3856710bf8ea8ddc4a01b52a61c88">null object</a>.  <a href="#ab4aa88742d17f4cba10346eaf53a9c98">More...</a><br /></td></tr>
<tr class="separator:ab4aa88742d17f4cba10346eaf53a9c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccae6d56922c7eaf4634e43e308dad2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a9ccae6d56922c7eaf4634e43e308dad2">NcVar</a> (const <a class="el" href="classnetCDF_1_1NcGroup.html">NcGroup</a> &amp;grp, const int &amp;varId)</td></tr>
<tr class="memdesc:a9ccae6d56922c7eaf4634e43e308dad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a variable .  <a href="#a9ccae6d56922c7eaf4634e43e308dad2">More...</a><br /></td></tr>
<tr class="separator:a9ccae6d56922c7eaf4634e43e308dad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3d493b50196885972b698d9773b4c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aea3d493b50196885972b698d9773b4c9">NcVar</a> (const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;ncVar)</td></tr>
<tr class="memdesc:aea3d493b50196885972b698d9773b4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor.  <a href="#aea3d493b50196885972b698d9773b4c9">More...</a><br /></td></tr>
<tr class="separator:aea3d493b50196885972b698d9773b4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764d808db44c8071ea177f8f9fbae04c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a764d808db44c8071ea177f8f9fbae04c">~NcVar</a> ()</td></tr>
<tr class="memdesc:a764d808db44c8071ea177f8f9fbae04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="#a764d808db44c8071ea177f8f9fbae04c">More...</a><br /></td></tr>
<tr class="separator:a764d808db44c8071ea177f8f9fbae04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4d6282ca2d01c9cb03107455eb4454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#acf4d6282ca2d01c9cb03107455eb4454">getAtt</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:acf4d6282ca2d01c9cb03107455eb4454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets attribute by name.  <a href="#acf4d6282ca2d01c9cb03107455eb4454">More...</a><br /></td></tr>
<tr class="separator:acf4d6282ca2d01c9cb03107455eb4454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79fe3ecb29591ef213ea18a3142efd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ac79fe3ecb29591ef213ea18a3142efd2">getAttCount</a> () const </td></tr>
<tr class="memdesc:ac79fe3ecb29591ef213ea18a3142efd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of attributes.  <a href="#ac79fe3ecb29591ef213ea18a3142efd2">More...</a><br /></td></tr>
<tr class="separator:ac79fe3ecb29591ef213ea18a3142efd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8041f272c7edf4ac74b979838bd099"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aae8041f272c7edf4ac74b979838bd099">getAtts</a> () const </td></tr>
<tr class="memdesc:aae8041f272c7edf4ac74b979838bd099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of attributes.  <a href="#aae8041f272c7edf4ac74b979838bd099">More...</a><br /></td></tr>
<tr class="separator:aae8041f272c7edf4ac74b979838bd099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b5f4f38dde165aebfe7e61d0f4e3c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVar.html#a6fa17911a9f7ec09cc05e34bc4f63a39">ChecksumMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a38b5f4f38dde165aebfe7e61d0f4e3c0">getChecksum</a> () const </td></tr>
<tr class="memdesc:a38b5f4f38dde165aebfe7e61d0f4e3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the checksum parameters of the variable.  <a href="#a38b5f4f38dde165aebfe7e61d0f4e3c0">More...</a><br /></td></tr>
<tr class="separator:a38b5f4f38dde165aebfe7e61d0f4e3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b267cf0903e6bca4493c2e4360aed00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a4b267cf0903e6bca4493c2e4360aed00">getChunkingParameters</a> (<a class="el" href="classnetCDF_1_1NcVar.html#a1e8425b2967665ab83f1e76abac2a76a">ChunkMode</a> &amp;chunkMode, std::vector&lt; size_t &gt; &amp;chunkSizes) const </td></tr>
<tr class="memdesc:a4b267cf0903e6bca4493c2e4360aed00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the chunking parameters.  <a href="#a4b267cf0903e6bca4493c2e4360aed00">More...</a><br /></td></tr>
<tr class="separator:a4b267cf0903e6bca4493c2e4360aed00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c01b4329a1c9d7ed0cb3bd13c3848a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a19c01b4329a1c9d7ed0cb3bd13c3848a">getCompressionParameters</a> (bool &amp;shuffleFilterEnabled, bool &amp;deflateFilterEnabled, int &amp;deflateLevel) const </td></tr>
<tr class="memdesc:a19c01b4329a1c9d7ed0cb3bd13c3848a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the compression parameters.  <a href="#a19c01b4329a1c9d7ed0cb3bd13c3848a">More...</a><br /></td></tr>
<tr class="separator:a19c01b4329a1c9d7ed0cb3bd13c3848a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96cb42e88ca00095bd09d082057fdf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcDim.html">NcDim</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ae96cb42e88ca00095bd09d082057fdf5">getDim</a> (int i) const </td></tr>
<tr class="memdesc:ae96cb42e88ca00095bd09d082057fdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the i'th <a class="el" href="classnetCDF_1_1NcDim.html" title="Class represents a netCDF dimension. ">NcDim</a> object.  <a href="#ae96cb42e88ca00095bd09d082057fdf5">More...</a><br /></td></tr>
<tr class="separator:ae96cb42e88ca00095bd09d082057fdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65173b804ae50806ce1a4ee0a1cab698"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a65173b804ae50806ce1a4ee0a1cab698">getDimCount</a> () const </td></tr>
<tr class="memdesc:a65173b804ae50806ce1a4ee0a1cab698"><td class="mdescLeft">&#160;</td><td class="mdescRight">The the number of dimensions.  <a href="#a65173b804ae50806ce1a4ee0a1cab698">More...</a><br /></td></tr>
<tr class="separator:a65173b804ae50806ce1a4ee0a1cab698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab952efcd760fd69b7b491732a3afdf5c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classnetCDF_1_1NcDim.html">NcDim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ab952efcd760fd69b7b491732a3afdf5c">getDims</a> () const </td></tr>
<tr class="memdesc:ab952efcd760fd69b7b491732a3afdf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of <a class="el" href="classnetCDF_1_1NcDim.html" title="Class represents a netCDF dimension. ">NcDim</a> objects.  <a href="#ab952efcd760fd69b7b491732a3afdf5c">More...</a><br /></td></tr>
<tr class="separator:ab952efcd760fd69b7b491732a3afdf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8f11bc557205faed4144ea57e9ba1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVar.html#ad6e882d6cc8aa698ef82b96e14eaa7a9">EndianMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a4b8f11bc557205faed4144ea57e9ba1a">getEndianness</a> () const </td></tr>
<tr class="memdesc:a4b8f11bc557205faed4144ea57e9ba1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the endianness of the variable.  <a href="#a4b8f11bc557205faed4144ea57e9ba1a">More...</a><br /></td></tr>
<tr class="separator:a4b8f11bc557205faed4144ea57e9ba1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb131a278d59c45cf18679eea0614c4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#abb131a278d59c45cf18679eea0614c4a">getFillModeParameters</a> (bool &amp;fillMode, void *fillValue=NULL) const </td></tr>
<tr class="memdesc:abb131a278d59c45cf18679eea0614c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience.  <a href="#abb131a278d59c45cf18679eea0614c4a">More...</a><br /></td></tr>
<tr class="separator:abb131a278d59c45cf18679eea0614c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7130dddb05775fe542382ad146bb11f9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7130dddb05775fe542382ad146bb11f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a7130dddb05775fe542382ad146bb11f9">getFillModeParameters</a> (bool &amp;fillMode, T &amp;fillValue) const </td></tr>
<tr class="memdesc:a7130dddb05775fe542382ad146bb11f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fill parameters.  <a href="#a7130dddb05775fe542382ad146bb11f9">More...</a><br /></td></tr>
<tr class="separator:a7130dddb05775fe542382ad146bb11f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccbfb2c9302452c7dddc7bfe59bf19b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a8ccbfb2c9302452c7dddc7bfe59bf19b">getId</a> () const </td></tr>
<tr class="memdesc:a8ccbfb2c9302452c7dddc7bfe59bf19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the variable id.  <a href="#a8ccbfb2c9302452c7dddc7bfe59bf19b">More...</a><br /></td></tr>
<tr class="separator:a8ccbfb2c9302452c7dddc7bfe59bf19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f1f355b78519cdbeca09f468b764b9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a80f1f355b78519cdbeca09f468b764b9">getName</a> () const </td></tr>
<tr class="memdesc:a80f1f355b78519cdbeca09f468b764b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of this <a class="el" href="classnetCDF_1_1NcVar.html" title="Class represents a netCDF variable. ">NcVar</a> object.  <a href="#a80f1f355b78519cdbeca09f468b764b9">More...</a><br /></td></tr>
<tr class="separator:a80f1f355b78519cdbeca09f468b764b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa375e8a5af9245e053c91b9f3ba4af0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcGroup.html">NcGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aa375e8a5af9245e053c91b9f3ba4af0f">getParentGroup</a> () const </td></tr>
<tr class="memdesc:aa375e8a5af9245e053c91b9f3ba4af0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets parent group.  <a href="#aa375e8a5af9245e053c91b9f3ba4af0f">More...</a><br /></td></tr>
<tr class="separator:aa375e8a5af9245e053c91b9f3ba4af0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cfe65ba5d48b32fa55b4c0c91bf1b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcType.html">NcType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a26cfe65ba5d48b32fa55b4c0c91bf1b8">getType</a> () const </td></tr>
<tr class="memdesc:a26cfe65ba5d48b32fa55b4c0c91bf1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variable type.  <a href="#a26cfe65ba5d48b32fa55b4c0c91bf1b8">More...</a><br /></td></tr>
<tr class="separator:a26cfe65ba5d48b32fa55b4c0c91bf1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb10fba7aa386e06551039bddd555c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#acfb10fba7aa386e06551039bddd555c3">getVar</a> (void *dataValues) const </td></tr>
<tr class="memdesc:acfb10fba7aa386e06551039bddd555c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience.  <a href="#acfb10fba7aa386e06551039bddd555c3">More...</a><br /></td></tr>
<tr class="separator:acfb10fba7aa386e06551039bddd555c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af861854a7c29a87de7cb101d78ad5dec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#af861854a7c29a87de7cb101d78ad5dec">getVar</a> (char **dataValues) const </td></tr>
<tr class="memdesc:af861854a7c29a87de7cb101d78ad5dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#af861854a7c29a87de7cb101d78ad5dec">More...</a><br /></td></tr>
<tr class="separator:af861854a7c29a87de7cb101d78ad5dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1827de6e9a01eba0123ac2d3ea20eda5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a1827de6e9a01eba0123ac2d3ea20eda5">getVar</a> (char *dataValues) const </td></tr>
<tr class="memdesc:a1827de6e9a01eba0123ac2d3ea20eda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a1827de6e9a01eba0123ac2d3ea20eda5">More...</a><br /></td></tr>
<tr class="separator:a1827de6e9a01eba0123ac2d3ea20eda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d971e3414b6d8d429b01ff90d5b9106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a2d971e3414b6d8d429b01ff90d5b9106">getVar</a> (unsigned char *dataValues) const </td></tr>
<tr class="memdesc:a2d971e3414b6d8d429b01ff90d5b9106"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a2d971e3414b6d8d429b01ff90d5b9106">More...</a><br /></td></tr>
<tr class="separator:a2d971e3414b6d8d429b01ff90d5b9106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc01a0a27dc2aef4b611d4920a52ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a4fc01a0a27dc2aef4b611d4920a52ace">getVar</a> (signed char *dataValues) const </td></tr>
<tr class="memdesc:a4fc01a0a27dc2aef4b611d4920a52ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a4fc01a0a27dc2aef4b611d4920a52ace">More...</a><br /></td></tr>
<tr class="separator:a4fc01a0a27dc2aef4b611d4920a52ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5986aaa88aad5790935543f574eb9ed7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a5986aaa88aad5790935543f574eb9ed7">getVar</a> (short *dataValues) const </td></tr>
<tr class="memdesc:a5986aaa88aad5790935543f574eb9ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a5986aaa88aad5790935543f574eb9ed7">More...</a><br /></td></tr>
<tr class="separator:a5986aaa88aad5790935543f574eb9ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066f94d2debff11e04bd8330c629602a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a066f94d2debff11e04bd8330c629602a">getVar</a> (int *dataValues) const </td></tr>
<tr class="memdesc:a066f94d2debff11e04bd8330c629602a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a066f94d2debff11e04bd8330c629602a">More...</a><br /></td></tr>
<tr class="separator:a066f94d2debff11e04bd8330c629602a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc031f1d34cca5dc8171894bfbd46310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#afc031f1d34cca5dc8171894bfbd46310">getVar</a> (long *dataValues) const </td></tr>
<tr class="memdesc:afc031f1d34cca5dc8171894bfbd46310"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#afc031f1d34cca5dc8171894bfbd46310">More...</a><br /></td></tr>
<tr class="separator:afc031f1d34cca5dc8171894bfbd46310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3232a3c0826689bb4b3dd62cb3e90f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#acc3232a3c0826689bb4b3dd62cb3e90f">getVar</a> (float *dataValues) const </td></tr>
<tr class="memdesc:acc3232a3c0826689bb4b3dd62cb3e90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#acc3232a3c0826689bb4b3dd62cb3e90f">More...</a><br /></td></tr>
<tr class="separator:acc3232a3c0826689bb4b3dd62cb3e90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269152bba0de2aa59abe82d38eec8dac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a269152bba0de2aa59abe82d38eec8dac">getVar</a> (double *dataValues) const </td></tr>
<tr class="memdesc:a269152bba0de2aa59abe82d38eec8dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a269152bba0de2aa59abe82d38eec8dac">More...</a><br /></td></tr>
<tr class="separator:a269152bba0de2aa59abe82d38eec8dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75ff3a384ecf824c91fa13dedb52e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a5f75ff3a384ecf824c91fa13dedb52e9">getVar</a> (unsigned short *dataValues) const </td></tr>
<tr class="memdesc:a5f75ff3a384ecf824c91fa13dedb52e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a5f75ff3a384ecf824c91fa13dedb52e9">More...</a><br /></td></tr>
<tr class="separator:a5f75ff3a384ecf824c91fa13dedb52e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf545f6790e25b9f4bea3752ae168f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#afdf545f6790e25b9f4bea3752ae168f8">getVar</a> (unsigned int *dataValues) const </td></tr>
<tr class="memdesc:afdf545f6790e25b9f4bea3752ae168f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#afdf545f6790e25b9f4bea3752ae168f8">More...</a><br /></td></tr>
<tr class="separator:afdf545f6790e25b9f4bea3752ae168f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c7727ffa8f4d5f7d27ad1011d161a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a66c7727ffa8f4d5f7d27ad1011d161a8">getVar</a> (unsigned long long *dataValues) const </td></tr>
<tr class="memdesc:a66c7727ffa8f4d5f7d27ad1011d161a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a66c7727ffa8f4d5f7d27ad1011d161a8">More...</a><br /></td></tr>
<tr class="separator:a66c7727ffa8f4d5f7d27ad1011d161a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1609dcb1106641201ddb606401f1ab93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a1609dcb1106641201ddb606401f1ab93">getVar</a> (long long *dataValues) const </td></tr>
<tr class="memdesc:a1609dcb1106641201ddb606401f1ab93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the entire data from an <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable.  <a href="#a1609dcb1106641201ddb606401f1ab93">More...</a><br /></td></tr>
<tr class="separator:a1609dcb1106641201ddb606401f1ab93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f82edf52e3c47254bb48f6c689732ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a3f82edf52e3c47254bb48f6c689732ff">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, void *datumValue) const </td></tr>
<tr class="memdesc:a3f82edf52e3c47254bb48f6c689732ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience.  <a href="#a3f82edf52e3c47254bb48f6c689732ff">More...</a><br /></td></tr>
<tr class="separator:a3f82edf52e3c47254bb48f6c689732ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9ebc6606de80f763142b2d8a347de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aff9ebc6606de80f763142b2d8a347de2">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, char **datumValue) const </td></tr>
<tr class="memdesc:aff9ebc6606de80f763142b2d8a347de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aff9ebc6606de80f763142b2d8a347de2">More...</a><br /></td></tr>
<tr class="separator:aff9ebc6606de80f763142b2d8a347de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e3c80d428bcec834c87cd7853b5f64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a05e3c80d428bcec834c87cd7853b5f64">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, char *datumValue) const </td></tr>
<tr class="memdesc:a05e3c80d428bcec834c87cd7853b5f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a05e3c80d428bcec834c87cd7853b5f64">More...</a><br /></td></tr>
<tr class="separator:a05e3c80d428bcec834c87cd7853b5f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c03b9f2dcb2e7e945a4f8e618bd158"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a51c03b9f2dcb2e7e945a4f8e618bd158">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, unsigned char *datumValue) const </td></tr>
<tr class="memdesc:a51c03b9f2dcb2e7e945a4f8e618bd158"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a51c03b9f2dcb2e7e945a4f8e618bd158">More...</a><br /></td></tr>
<tr class="separator:a51c03b9f2dcb2e7e945a4f8e618bd158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308342b38312462b197bd25accf0deba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a308342b38312462b197bd25accf0deba">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, signed char *datumValue) const </td></tr>
<tr class="memdesc:a308342b38312462b197bd25accf0deba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a308342b38312462b197bd25accf0deba">More...</a><br /></td></tr>
<tr class="separator:a308342b38312462b197bd25accf0deba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4656747476e6e2053b58b8bab412b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a4e4656747476e6e2053b58b8bab412b5">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, short *datumValue) const </td></tr>
<tr class="memdesc:a4e4656747476e6e2053b58b8bab412b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a4e4656747476e6e2053b58b8bab412b5">More...</a><br /></td></tr>
<tr class="separator:a4e4656747476e6e2053b58b8bab412b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab308dabaf2e507e5a62166777e983b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#abab308dabaf2e507e5a62166777e983b">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, int *datumValue) const </td></tr>
<tr class="memdesc:abab308dabaf2e507e5a62166777e983b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#abab308dabaf2e507e5a62166777e983b">More...</a><br /></td></tr>
<tr class="separator:abab308dabaf2e507e5a62166777e983b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398c167ae0cc994208b61b2422bf2ea3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a398c167ae0cc994208b61b2422bf2ea3">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, long *datumValue) const </td></tr>
<tr class="memdesc:a398c167ae0cc994208b61b2422bf2ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a398c167ae0cc994208b61b2422bf2ea3">More...</a><br /></td></tr>
<tr class="separator:a398c167ae0cc994208b61b2422bf2ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf05266166de1bec4d1283390d358e26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#adf05266166de1bec4d1283390d358e26">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, float *datumValue) const </td></tr>
<tr class="memdesc:adf05266166de1bec4d1283390d358e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#adf05266166de1bec4d1283390d358e26">More...</a><br /></td></tr>
<tr class="separator:adf05266166de1bec4d1283390d358e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467fcb92064bb9067ef9da116b0f93a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a467fcb92064bb9067ef9da116b0f93a7">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, double *datumValue) const </td></tr>
<tr class="memdesc:a467fcb92064bb9067ef9da116b0f93a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a467fcb92064bb9067ef9da116b0f93a7">More...</a><br /></td></tr>
<tr class="separator:a467fcb92064bb9067ef9da116b0f93a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e84fe7fec3c38023a93927c5f5763c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad2e84fe7fec3c38023a93927c5f5763c">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, unsigned short *datumValue) const </td></tr>
<tr class="memdesc:ad2e84fe7fec3c38023a93927c5f5763c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad2e84fe7fec3c38023a93927c5f5763c">More...</a><br /></td></tr>
<tr class="separator:ad2e84fe7fec3c38023a93927c5f5763c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac88e260332e4316f956cb66b7f947a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aac88e260332e4316f956cb66b7f947a9">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, unsigned int *datumValue) const </td></tr>
<tr class="memdesc:aac88e260332e4316f956cb66b7f947a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aac88e260332e4316f956cb66b7f947a9">More...</a><br /></td></tr>
<tr class="separator:aac88e260332e4316f956cb66b7f947a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25ef840aa5d8c563245c568a5333d88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad25ef840aa5d8c563245c568a5333d88">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, unsigned long long *datumValue) const </td></tr>
<tr class="memdesc:ad25ef840aa5d8c563245c568a5333d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad25ef840aa5d8c563245c568a5333d88">More...</a><br /></td></tr>
<tr class="separator:ad25ef840aa5d8c563245c568a5333d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7349b33cb8e7b246c3acdc4bd575266d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a7349b33cb8e7b246c3acdc4bd575266d">getVar</a> (const std::vector&lt; size_t &gt; &amp;index, long long *datumValue) const </td></tr>
<tr class="memdesc:a7349b33cb8e7b246c3acdc4bd575266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single datum value from a variable of an open <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> dataset.  <a href="#a7349b33cb8e7b246c3acdc4bd575266d">More...</a><br /></td></tr>
<tr class="separator:a7349b33cb8e7b246c3acdc4bd575266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2951947e67ba1d76a9da6929f155dd38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a2951947e67ba1d76a9da6929f155dd38">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, void *dataValues) const </td></tr>
<tr class="memdesc:a2951947e67ba1d76a9da6929f155dd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience.  <a href="#a2951947e67ba1d76a9da6929f155dd38">More...</a><br /></td></tr>
<tr class="separator:a2951947e67ba1d76a9da6929f155dd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de17f990c78ccdd83121392d02c446a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a5de17f990c78ccdd83121392d02c446a">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, char **dataValues) const </td></tr>
<tr class="memdesc:a5de17f990c78ccdd83121392d02c446a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a5de17f990c78ccdd83121392d02c446a">More...</a><br /></td></tr>
<tr class="separator:a5de17f990c78ccdd83121392d02c446a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f74c300f50b34ea366f54d224a3968a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a4f74c300f50b34ea366f54d224a3968a">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, char *dataValues) const </td></tr>
<tr class="memdesc:a4f74c300f50b34ea366f54d224a3968a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a4f74c300f50b34ea366f54d224a3968a">More...</a><br /></td></tr>
<tr class="separator:a4f74c300f50b34ea366f54d224a3968a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0edb01b9c97a58f587a4f0e72aeb868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ab0edb01b9c97a58f587a4f0e72aeb868">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, unsigned char *dataValues) const </td></tr>
<tr class="memdesc:ab0edb01b9c97a58f587a4f0e72aeb868"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ab0edb01b9c97a58f587a4f0e72aeb868">More...</a><br /></td></tr>
<tr class="separator:ab0edb01b9c97a58f587a4f0e72aeb868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a1a8ad763b337518cbca19d4c48150"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a92a1a8ad763b337518cbca19d4c48150">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, signed char *dataValues) const </td></tr>
<tr class="memdesc:a92a1a8ad763b337518cbca19d4c48150"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a92a1a8ad763b337518cbca19d4c48150">More...</a><br /></td></tr>
<tr class="separator:a92a1a8ad763b337518cbca19d4c48150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf75223a926d65f8bef7a68c60ba02bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#abf75223a926d65f8bef7a68c60ba02bc">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, short *dataValues) const </td></tr>
<tr class="memdesc:abf75223a926d65f8bef7a68c60ba02bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#abf75223a926d65f8bef7a68c60ba02bc">More...</a><br /></td></tr>
<tr class="separator:abf75223a926d65f8bef7a68c60ba02bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae935f8bd822cd9f17cec7b66b9910941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ae935f8bd822cd9f17cec7b66b9910941">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, int *dataValues) const </td></tr>
<tr class="memdesc:ae935f8bd822cd9f17cec7b66b9910941"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ae935f8bd822cd9f17cec7b66b9910941">More...</a><br /></td></tr>
<tr class="separator:ae935f8bd822cd9f17cec7b66b9910941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8333c4c1cf16636dea144eae2a6b30c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad8333c4c1cf16636dea144eae2a6b30c">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, long *dataValues) const </td></tr>
<tr class="memdesc:ad8333c4c1cf16636dea144eae2a6b30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad8333c4c1cf16636dea144eae2a6b30c">More...</a><br /></td></tr>
<tr class="separator:ad8333c4c1cf16636dea144eae2a6b30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54943eb6861471d3eef366d81958153e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a54943eb6861471d3eef366d81958153e">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, float *dataValues) const </td></tr>
<tr class="memdesc:a54943eb6861471d3eef366d81958153e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a54943eb6861471d3eef366d81958153e">More...</a><br /></td></tr>
<tr class="separator:a54943eb6861471d3eef366d81958153e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d273a0d5f572d04b78c92cd0f5d41b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a74d273a0d5f572d04b78c92cd0f5d41b">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, double *dataValues) const </td></tr>
<tr class="memdesc:a74d273a0d5f572d04b78c92cd0f5d41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a74d273a0d5f572d04b78c92cd0f5d41b">More...</a><br /></td></tr>
<tr class="separator:a74d273a0d5f572d04b78c92cd0f5d41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd98af4a70384b9f4fe5524dc08ee40c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#afd98af4a70384b9f4fe5524dc08ee40c">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, unsigned short *dataValues) const </td></tr>
<tr class="memdesc:afd98af4a70384b9f4fe5524dc08ee40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#afd98af4a70384b9f4fe5524dc08ee40c">More...</a><br /></td></tr>
<tr class="separator:afd98af4a70384b9f4fe5524dc08ee40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc576e42235ddd131db9c382de4a9ebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#abc576e42235ddd131db9c382de4a9ebe">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, unsigned int *dataValues) const </td></tr>
<tr class="memdesc:abc576e42235ddd131db9c382de4a9ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#abc576e42235ddd131db9c382de4a9ebe">More...</a><br /></td></tr>
<tr class="separator:abc576e42235ddd131db9c382de4a9ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659859a9afba4c9f9795402b9ba8752e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a659859a9afba4c9f9795402b9ba8752e">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, unsigned long long *dataValues) const </td></tr>
<tr class="memdesc:a659859a9afba4c9f9795402b9ba8752e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a659859a9afba4c9f9795402b9ba8752e">More...</a><br /></td></tr>
<tr class="separator:a659859a9afba4c9f9795402b9ba8752e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f88dcaab7fc497f861c6080e7cbff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a66f88dcaab7fc497f861c6080e7cbff9">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, long long *dataValues) const </td></tr>
<tr class="memdesc:a66f88dcaab7fc497f861c6080e7cbff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of values from a <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable of an open <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> dataset.  <a href="#a66f88dcaab7fc497f861c6080e7cbff9">More...</a><br /></td></tr>
<tr class="separator:a66f88dcaab7fc497f861c6080e7cbff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f73b5dee3d535e4e2aed3011c7dabf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a67f73b5dee3d535e4e2aed3011c7dabf">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, void *dataValues) const </td></tr>
<tr class="memdesc:a67f73b5dee3d535e4e2aed3011c7dabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience.  <a href="#a67f73b5dee3d535e4e2aed3011c7dabf">More...</a><br /></td></tr>
<tr class="separator:a67f73b5dee3d535e4e2aed3011c7dabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ff5ff744d149b82a75b3d900c8e817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a12ff5ff744d149b82a75b3d900c8e817">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, char **dataValues) const </td></tr>
<tr class="memdesc:a12ff5ff744d149b82a75b3d900c8e817"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a12ff5ff744d149b82a75b3d900c8e817">More...</a><br /></td></tr>
<tr class="separator:a12ff5ff744d149b82a75b3d900c8e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb89b43711305f03bc5e6548b949167b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#afb89b43711305f03bc5e6548b949167b">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, char *dataValues) const </td></tr>
<tr class="memdesc:afb89b43711305f03bc5e6548b949167b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#afb89b43711305f03bc5e6548b949167b">More...</a><br /></td></tr>
<tr class="separator:afb89b43711305f03bc5e6548b949167b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b06c60f4f569de7d89f9c4dcf1b52f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aa8b06c60f4f569de7d89f9c4dcf1b52f">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, unsigned char *dataValues) const </td></tr>
<tr class="memdesc:aa8b06c60f4f569de7d89f9c4dcf1b52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aa8b06c60f4f569de7d89f9c4dcf1b52f">More...</a><br /></td></tr>
<tr class="separator:aa8b06c60f4f569de7d89f9c4dcf1b52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26922664de4212378961be34acc5cb13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a26922664de4212378961be34acc5cb13">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, signed char *dataValues) const </td></tr>
<tr class="memdesc:a26922664de4212378961be34acc5cb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a26922664de4212378961be34acc5cb13">More...</a><br /></td></tr>
<tr class="separator:a26922664de4212378961be34acc5cb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7c569fb75a92b3f145e8eb4c3a376d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#abd7c569fb75a92b3f145e8eb4c3a376d">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, short *dataValues) const </td></tr>
<tr class="memdesc:abd7c569fb75a92b3f145e8eb4c3a376d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#abd7c569fb75a92b3f145e8eb4c3a376d">More...</a><br /></td></tr>
<tr class="separator:abd7c569fb75a92b3f145e8eb4c3a376d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecd56061917355fcdde3e90201c402f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a1ecd56061917355fcdde3e90201c402f">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, int *dataValues) const </td></tr>
<tr class="memdesc:a1ecd56061917355fcdde3e90201c402f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a1ecd56061917355fcdde3e90201c402f">More...</a><br /></td></tr>
<tr class="separator:a1ecd56061917355fcdde3e90201c402f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a37a66216c366847cea2f7e9b527e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ac3a37a66216c366847cea2f7e9b527e3">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, long *dataValues) const </td></tr>
<tr class="memdesc:ac3a37a66216c366847cea2f7e9b527e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ac3a37a66216c366847cea2f7e9b527e3">More...</a><br /></td></tr>
<tr class="separator:ac3a37a66216c366847cea2f7e9b527e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8330e38aa414bd9308eda6bd481a23c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a8330e38aa414bd9308eda6bd481a23c6">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, float *dataValues) const </td></tr>
<tr class="memdesc:a8330e38aa414bd9308eda6bd481a23c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a8330e38aa414bd9308eda6bd481a23c6">More...</a><br /></td></tr>
<tr class="separator:a8330e38aa414bd9308eda6bd481a23c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df0be1039713d3c37b6902dc0b67dfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a2df0be1039713d3c37b6902dc0b67dfd">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, double *dataValues) const </td></tr>
<tr class="memdesc:a2df0be1039713d3c37b6902dc0b67dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a2df0be1039713d3c37b6902dc0b67dfd">More...</a><br /></td></tr>
<tr class="separator:a2df0be1039713d3c37b6902dc0b67dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbeae65265387b284473a1a53c2c729"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#acbbeae65265387b284473a1a53c2c729">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, unsigned short *dataValues) const </td></tr>
<tr class="memdesc:acbbeae65265387b284473a1a53c2c729"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#acbbeae65265387b284473a1a53c2c729">More...</a><br /></td></tr>
<tr class="separator:acbbeae65265387b284473a1a53c2c729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6bb27610ff15a01b83efc9c7426634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aca6bb27610ff15a01b83efc9c7426634">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, unsigned int *dataValues) const </td></tr>
<tr class="memdesc:aca6bb27610ff15a01b83efc9c7426634"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aca6bb27610ff15a01b83efc9c7426634">More...</a><br /></td></tr>
<tr class="separator:aca6bb27610ff15a01b83efc9c7426634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53449174ec25c443ae620b87e5b5e415"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a53449174ec25c443ae620b87e5b5e415">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, unsigned long long *dataValues) const </td></tr>
<tr class="memdesc:a53449174ec25c443ae620b87e5b5e415"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a53449174ec25c443ae620b87e5b5e415">More...</a><br /></td></tr>
<tr class="separator:a53449174ec25c443ae620b87e5b5e415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecda6d270e5713fc5bea6a22306ae1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#adecda6d270e5713fc5bea6a22306ae1d">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, long long *dataValues) const </td></tr>
<tr class="memdesc:adecda6d270e5713fc5bea6a22306ae1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a subsampled (strided) array section of values from a <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable.  <a href="#adecda6d270e5713fc5bea6a22306ae1d">More...</a><br /></td></tr>
<tr class="separator:adecda6d270e5713fc5bea6a22306ae1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f0a4f913ee85130fd9d89c910d9c05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad6f0a4f913ee85130fd9d89c910d9c05">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, void *dataValues) const </td></tr>
<tr class="memdesc:ad6f0a4f913ee85130fd9d89c910d9c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience.  <a href="#ad6f0a4f913ee85130fd9d89c910d9c05">More...</a><br /></td></tr>
<tr class="separator:ad6f0a4f913ee85130fd9d89c910d9c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae55bb18a426f1665931385c7ce1854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a3ae55bb18a426f1665931385c7ce1854">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, char **dataValues) const </td></tr>
<tr class="memdesc:a3ae55bb18a426f1665931385c7ce1854"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a3ae55bb18a426f1665931385c7ce1854">More...</a><br /></td></tr>
<tr class="separator:a3ae55bb18a426f1665931385c7ce1854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de0b6ec0b412d811cece5d70b7bf04d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a6de0b6ec0b412d811cece5d70b7bf04d">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, char *dataValues) const </td></tr>
<tr class="memdesc:a6de0b6ec0b412d811cece5d70b7bf04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a6de0b6ec0b412d811cece5d70b7bf04d">More...</a><br /></td></tr>
<tr class="separator:a6de0b6ec0b412d811cece5d70b7bf04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bb5acc43b9c82a760ee8eb588f1c90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad6bb5acc43b9c82a760ee8eb588f1c90">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, unsigned char *dataValues) const </td></tr>
<tr class="memdesc:ad6bb5acc43b9c82a760ee8eb588f1c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad6bb5acc43b9c82a760ee8eb588f1c90">More...</a><br /></td></tr>
<tr class="separator:ad6bb5acc43b9c82a760ee8eb588f1c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83e3c6e12d538d49612758fae530b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad83e3c6e12d538d49612758fae530b73">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, signed char *dataValues) const </td></tr>
<tr class="memdesc:ad83e3c6e12d538d49612758fae530b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad83e3c6e12d538d49612758fae530b73">More...</a><br /></td></tr>
<tr class="separator:ad83e3c6e12d538d49612758fae530b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a0c9c468bec1a14e1ba0e1e6f6ab24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a43a0c9c468bec1a14e1ba0e1e6f6ab24">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, short *dataValues) const </td></tr>
<tr class="memdesc:a43a0c9c468bec1a14e1ba0e1e6f6ab24"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a43a0c9c468bec1a14e1ba0e1e6f6ab24">More...</a><br /></td></tr>
<tr class="separator:a43a0c9c468bec1a14e1ba0e1e6f6ab24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b70f5fe34fdd29f6de7e7f3edfb56e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a19b70f5fe34fdd29f6de7e7f3edfb56e">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, int *dataValues) const </td></tr>
<tr class="memdesc:a19b70f5fe34fdd29f6de7e7f3edfb56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a19b70f5fe34fdd29f6de7e7f3edfb56e">More...</a><br /></td></tr>
<tr class="separator:a19b70f5fe34fdd29f6de7e7f3edfb56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f9f8d7741537022753a48acc66ab56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ac0f9f8d7741537022753a48acc66ab56">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, long *dataValues) const </td></tr>
<tr class="memdesc:ac0f9f8d7741537022753a48acc66ab56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ac0f9f8d7741537022753a48acc66ab56">More...</a><br /></td></tr>
<tr class="separator:ac0f9f8d7741537022753a48acc66ab56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af212b0f70aa24c5112187c4932ea3b2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#af212b0f70aa24c5112187c4932ea3b2e">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, float *dataValues) const </td></tr>
<tr class="memdesc:af212b0f70aa24c5112187c4932ea3b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#af212b0f70aa24c5112187c4932ea3b2e">More...</a><br /></td></tr>
<tr class="separator:af212b0f70aa24c5112187c4932ea3b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b5c6be93a66c80588356fd6b21ef42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aa0b5c6be93a66c80588356fd6b21ef42">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, double *dataValues) const </td></tr>
<tr class="memdesc:aa0b5c6be93a66c80588356fd6b21ef42"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aa0b5c6be93a66c80588356fd6b21ef42">More...</a><br /></td></tr>
<tr class="separator:aa0b5c6be93a66c80588356fd6b21ef42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbb0ec2911f4fe1dc9a9abf498dc2c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a8cbb0ec2911f4fe1dc9a9abf498dc2c5">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, unsigned short *dataValues) const </td></tr>
<tr class="memdesc:a8cbb0ec2911f4fe1dc9a9abf498dc2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a8cbb0ec2911f4fe1dc9a9abf498dc2c5">More...</a><br /></td></tr>
<tr class="separator:a8cbb0ec2911f4fe1dc9a9abf498dc2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d8035ff1ac2b032abcde98633cd941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a06d8035ff1ac2b032abcde98633cd941">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, unsigned int *dataValues) const </td></tr>
<tr class="memdesc:a06d8035ff1ac2b032abcde98633cd941"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a06d8035ff1ac2b032abcde98633cd941">More...</a><br /></td></tr>
<tr class="separator:a06d8035ff1ac2b032abcde98633cd941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e3c592cd79e7505bebb0197de3ab54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#af6e3c592cd79e7505bebb0197de3ab54">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, unsigned long long *dataValues) const </td></tr>
<tr class="memdesc:af6e3c592cd79e7505bebb0197de3ab54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#af6e3c592cd79e7505bebb0197de3ab54">More...</a><br /></td></tr>
<tr class="separator:af6e3c592cd79e7505bebb0197de3ab54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc3e28ca5637d359da13aaf59e96cca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a8cc3e28ca5637d359da13aaf59e96cca">getVar</a> (const std::vector&lt; size_t &gt; &amp;start, const std::vector&lt; size_t &gt; &amp;count, const std::vector&lt; ptrdiff_t &gt; &amp;stride, const std::vector&lt; ptrdiff_t &gt; &amp;imap, long long *dataValues) const </td></tr>
<tr class="memdesc:a8cc3e28ca5637d359da13aaf59e96cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a mapped array section of values from a <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable.  <a href="#a8cc3e28ca5637d359da13aaf59e96cca">More...</a><br /></td></tr>
<tr class="separator:a8cc3e28ca5637d359da13aaf59e96cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff3856710bf8ea8ddc4a01b52a61c88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#abff3856710bf8ea8ddc4a01b52a61c88">isNull</a> () const </td></tr>
<tr class="memdesc:abff3856710bf8ea8ddc4a01b52a61c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this object variable is not defined.  <a href="#abff3856710bf8ea8ddc4a01b52a61c88">More...</a><br /></td></tr>
<tr class="separator:abff3856710bf8ea8ddc4a01b52a61c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90c14c2561e82c877ed6ce9bf147695"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aa90c14c2561e82c877ed6ce9bf147695">operator!=</a> (const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;rhs) const </td></tr>
<tr class="memdesc:aa90c14c2561e82c877ed6ce9bf147695"><td class="mdescLeft">&#160;</td><td class="mdescRight">!= operator  <a href="#aa90c14c2561e82c877ed6ce9bf147695">More...</a><br /></td></tr>
<tr class="separator:aa90c14c2561e82c877ed6ce9bf147695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c667eccb01b705ff3e8869d0c0829ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a7c667eccb01b705ff3e8869d0c0829ee">operator=</a> (const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;rhs)</td></tr>
<tr class="memdesc:a7c667eccb01b705ff3e8869d0c0829ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment operator  <a href="#a7c667eccb01b705ff3e8869d0c0829ee">More...</a><br /></td></tr>
<tr class="separator:a7c667eccb01b705ff3e8869d0c0829ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71e9c962907c2eeb21197c3b2e2add8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#af71e9c962907c2eeb21197c3b2e2add8">operator==</a> (const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;rhs) const </td></tr>
<tr class="memdesc:af71e9c962907c2eeb21197c3b2e2add8"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalence operator  <a href="#af71e9c962907c2eeb21197c3b2e2add8">More...</a><br /></td></tr>
<tr class="separator:af71e9c962907c2eeb21197c3b2e2add8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2881b1d3ed255179637e752367fca35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aa2881b1d3ed255179637e752367fca35">putAtt</a> (const std::string &amp;name, size_t len, const char **dataValues) const </td></tr>
<tr class="memdesc:aa2881b1d3ed255179637e752367fca35"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aa2881b1d3ed255179637e752367fca35">More...</a><br /></td></tr>
<tr class="separator:aa2881b1d3ed255179637e752367fca35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaee339673070d4648d515a104b2230d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aaaee339673070d4648d515a104b2230d">putAtt</a> (const std::string &amp;name, const std::string &amp;dataValues) const </td></tr>
<tr class="memdesc:aaaee339673070d4648d515a104b2230d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aaaee339673070d4648d515a104b2230d">More...</a><br /></td></tr>
<tr class="separator:aaaee339673070d4648d515a104b2230d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e0ebea6d405754cff7ac12348bb1d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a26e0ebea6d405754cff7ac12348bb1d5">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, size_t len, const unsigned char *dataValues) const </td></tr>
<tr class="memdesc:a26e0ebea6d405754cff7ac12348bb1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a26e0ebea6d405754cff7ac12348bb1d5">More...</a><br /></td></tr>
<tr class="separator:a26e0ebea6d405754cff7ac12348bb1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1806cfa7e28ec71ad816c1609eb5ba9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a1806cfa7e28ec71ad816c1609eb5ba9d">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, size_t len, const signed char *dataValues) const </td></tr>
<tr class="memdesc:a1806cfa7e28ec71ad816c1609eb5ba9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a1806cfa7e28ec71ad816c1609eb5ba9d">More...</a><br /></td></tr>
<tr class="separator:a1806cfa7e28ec71ad816c1609eb5ba9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5558749ec34f11e92634bde7bef6cbec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a5558749ec34f11e92634bde7bef6cbec">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, short datumValue) const </td></tr>
<tr class="memdesc:a5558749ec34f11e92634bde7bef6cbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a5558749ec34f11e92634bde7bef6cbec">More...</a><br /></td></tr>
<tr class="separator:a5558749ec34f11e92634bde7bef6cbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a2ad2bcc7aa4d71f499c5db5a10329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aa2a2ad2bcc7aa4d71f499c5db5a10329">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, int datumValue) const </td></tr>
<tr class="memdesc:aa2a2ad2bcc7aa4d71f499c5db5a10329"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aa2a2ad2bcc7aa4d71f499c5db5a10329">More...</a><br /></td></tr>
<tr class="separator:aa2a2ad2bcc7aa4d71f499c5db5a10329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5310e2a7e6d4e7ef38ccd65d900e7546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a5310e2a7e6d4e7ef38ccd65d900e7546">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, long datumValue) const </td></tr>
<tr class="memdesc:a5310e2a7e6d4e7ef38ccd65d900e7546"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a5310e2a7e6d4e7ef38ccd65d900e7546">More...</a><br /></td></tr>
<tr class="separator:a5310e2a7e6d4e7ef38ccd65d900e7546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4469fef6f9625fc2504c5fbfeb5e034"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad4469fef6f9625fc2504c5fbfeb5e034">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, float datumValue) const </td></tr>
<tr class="memdesc:ad4469fef6f9625fc2504c5fbfeb5e034"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad4469fef6f9625fc2504c5fbfeb5e034">More...</a><br /></td></tr>
<tr class="separator:ad4469fef6f9625fc2504c5fbfeb5e034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb5d76a8dc83c5e9699f69b58bcd2ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aabb5d76a8dc83c5e9699f69b58bcd2ea">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, double datumValue) const </td></tr>
<tr class="memdesc:aabb5d76a8dc83c5e9699f69b58bcd2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aabb5d76a8dc83c5e9699f69b58bcd2ea">More...</a><br /></td></tr>
<tr class="separator:aabb5d76a8dc83c5e9699f69b58bcd2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0287fe19cd8344edcab17c0c59fa2091"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a0287fe19cd8344edcab17c0c59fa2091">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, unsigned short datumValue) const </td></tr>
<tr class="memdesc:a0287fe19cd8344edcab17c0c59fa2091"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a0287fe19cd8344edcab17c0c59fa2091">More...</a><br /></td></tr>
<tr class="separator:a0287fe19cd8344edcab17c0c59fa2091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fe064c2ab7d62f47e77be881051c61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a97fe064c2ab7d62f47e77be881051c61">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, unsigned int datumValue) const </td></tr>
<tr class="memdesc:a97fe064c2ab7d62f47e77be881051c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a97fe064c2ab7d62f47e77be881051c61">More...</a><br /></td></tr>
<tr class="separator:a97fe064c2ab7d62f47e77be881051c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eda7fc61fb6609e65719abf47621ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ab6eda7fc61fb6609e65719abf47621ca">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, unsigned long long datumValue) const </td></tr>
<tr class="memdesc:ab6eda7fc61fb6609e65719abf47621ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ab6eda7fc61fb6609e65719abf47621ca">More...</a><br /></td></tr>
<tr class="separator:ab6eda7fc61fb6609e65719abf47621ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa51d0607796fe05b8de4e5a318a1d86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aaa51d0607796fe05b8de4e5a318a1d86">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, long long datumValue) const </td></tr>
<tr class="memdesc:aaa51d0607796fe05b8de4e5a318a1d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aaa51d0607796fe05b8de4e5a318a1d86">More...</a><br /></td></tr>
<tr class="separator:aaa51d0607796fe05b8de4e5a318a1d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0542684eb439ca17ee34b98fbfd13651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a0542684eb439ca17ee34b98fbfd13651">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, size_t len, const short *dataValues) const </td></tr>
<tr class="memdesc:a0542684eb439ca17ee34b98fbfd13651"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a0542684eb439ca17ee34b98fbfd13651">More...</a><br /></td></tr>
<tr class="separator:a0542684eb439ca17ee34b98fbfd13651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b88cfa23474981cf70fc5d3a682057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a80b88cfa23474981cf70fc5d3a682057">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, size_t len, const int *dataValues) const </td></tr>
<tr class="memdesc:a80b88cfa23474981cf70fc5d3a682057"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a80b88cfa23474981cf70fc5d3a682057">More...</a><br /></td></tr>
<tr class="separator:a80b88cfa23474981cf70fc5d3a682057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0404234f12d4dc468c889698ef5486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aad0404234f12d4dc468c889698ef5486">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, size_t len, const long *dataValues) const </td></tr>
<tr class="memdesc:aad0404234f12d4dc468c889698ef5486"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aad0404234f12d4dc468c889698ef5486">More...</a><br /></td></tr>
<tr class="separator:aad0404234f12d4dc468c889698ef5486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac28cb6d0de6317e867c31942ccac65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#adac28cb6d0de6317e867c31942ccac65">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, size_t len, const float *dataValues) const </td></tr>
<tr class="memdesc:adac28cb6d0de6317e867c31942ccac65"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#adac28cb6d0de6317e867c31942ccac65">More...</a><br /></td></tr>
<tr class="separator:adac28cb6d0de6317e867c31942ccac65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c3ce7eb1fa4bba2e2d1602a325b779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a46c3ce7eb1fa4bba2e2d1602a325b779">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, size_t len, const double *dataValues) const </td></tr>
<tr class="memdesc:a46c3ce7eb1fa4bba2e2d1602a325b779"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a46c3ce7eb1fa4bba2e2d1602a325b779">More...</a><br /></td></tr>
<tr class="separator:a46c3ce7eb1fa4bba2e2d1602a325b779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67a6aa2952057b4966d77c183e52609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad67a6aa2952057b4966d77c183e52609">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, size_t len, const unsigned short *dataValues) const </td></tr>
<tr class="memdesc:ad67a6aa2952057b4966d77c183e52609"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad67a6aa2952057b4966d77c183e52609">More...</a><br /></td></tr>
<tr class="separator:ad67a6aa2952057b4966d77c183e52609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251f52d58c2858ba3ca9e24e7a77606b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a251f52d58c2858ba3ca9e24e7a77606b">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, size_t len, const unsigned int *dataValues) const </td></tr>
<tr class="memdesc:a251f52d58c2858ba3ca9e24e7a77606b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a251f52d58c2858ba3ca9e24e7a77606b">More...</a><br /></td></tr>
<tr class="separator:a251f52d58c2858ba3ca9e24e7a77606b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c071bb9428f6d83357a90bc41791c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad9c071bb9428f6d83357a90bc41791c1">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, size_t len, const unsigned long long *dataValues) const </td></tr>
<tr class="memdesc:ad9c071bb9428f6d83357a90bc41791c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad9c071bb9428f6d83357a90bc41791c1">More...</a><br /></td></tr>
<tr class="separator:ad9c071bb9428f6d83357a90bc41791c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60a8702f75da8e1240b95293d5d2337"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad60a8702f75da8e1240b95293d5d2337">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, size_t len, const long long *dataValues) const </td></tr>
<tr class="memdesc:ad60a8702f75da8e1240b95293d5d2337"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad60a8702f75da8e1240b95293d5d2337">More...</a><br /></td></tr>
<tr class="separator:ad60a8702f75da8e1240b95293d5d2337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0e606efd43f079dfd21bb6e1e05f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#abc0e606efd43f079dfd21bb6e1e05f94">putAtt</a> (const std::string &amp;name, const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;type, size_t len, const void *dataValues) const </td></tr>
<tr class="memdesc:abc0e606efd43f079dfd21bb6e1e05f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new variable attribute or if already exisiting replaces it.  <a href="#abc0e606efd43f079dfd21bb6e1e05f94">More...</a><br /></td></tr>
<tr class="separator:abc0e606efd43f079dfd21bb6e1e05f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3206fa2a7b72b8b27912c74edda685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a2c3206fa2a7b72b8b27912c74edda685">putVar</a> (const void *dataValues) const </td></tr>
<tr class="memdesc:a2c3206fa2a7b72b8b27912c74edda685"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience.  <a href="#a2c3206fa2a7b72b8b27912c74edda685">More...</a><br /></td></tr>
<tr class="separator:a2c3206fa2a7b72b8b27912c74edda685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e4048e2a354d95115602326591505a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a62e4048e2a354d95115602326591505a">putVar</a> (const char **dataValues) const </td></tr>
<tr class="memdesc:a62e4048e2a354d95115602326591505a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a62e4048e2a354d95115602326591505a">More...</a><br /></td></tr>
<tr class="separator:a62e4048e2a354d95115602326591505a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65d0ddf3203b7dbb8d1893c361bd29f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad65d0ddf3203b7dbb8d1893c361bd29f">putVar</a> (const char *dataValues) const </td></tr>
<tr class="memdesc:ad65d0ddf3203b7dbb8d1893c361bd29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad65d0ddf3203b7dbb8d1893c361bd29f">More...</a><br /></td></tr>
<tr class="separator:ad65d0ddf3203b7dbb8d1893c361bd29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86f7194de16cf6704be6b4b1d769871"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ae86f7194de16cf6704be6b4b1d769871">putVar</a> (const unsigned char *dataValues) const </td></tr>
<tr class="memdesc:ae86f7194de16cf6704be6b4b1d769871"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ae86f7194de16cf6704be6b4b1d769871">More...</a><br /></td></tr>
<tr class="separator:ae86f7194de16cf6704be6b4b1d769871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f5b11910f537b0bd08851a9841f10b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a61f5b11910f537b0bd08851a9841f10b">putVar</a> (const signed char *dataValues) const </td></tr>
<tr class="memdesc:a61f5b11910f537b0bd08851a9841f10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a61f5b11910f537b0bd08851a9841f10b">More...</a><br /></td></tr>
<tr class="separator:a61f5b11910f537b0bd08851a9841f10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27424c55d400205a760836c8233c0661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a27424c55d400205a760836c8233c0661">putVar</a> (const short *dataValues) const </td></tr>
<tr class="memdesc:a27424c55d400205a760836c8233c0661"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a27424c55d400205a760836c8233c0661">More...</a><br /></td></tr>
<tr class="separator:a27424c55d400205a760836c8233c0661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432ad4bde6d6761d56722ba4f1c5a81f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a432ad4bde6d6761d56722ba4f1c5a81f">putVar</a> (const int *dataValues) const </td></tr>
<tr class="memdesc:a432ad4bde6d6761d56722ba4f1c5a81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a432ad4bde6d6761d56722ba4f1c5a81f">More...</a><br /></td></tr>
<tr class="separator:a432ad4bde6d6761d56722ba4f1c5a81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7613aa992db773e277e064e706572ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#af7613aa992db773e277e064e706572ee">putVar</a> (const long *dataValues) const </td></tr>
<tr class="memdesc:af7613aa992db773e277e064e706572ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#af7613aa992db773e277e064e706572ee">More...</a><br /></td></tr>
<tr class="separator:af7613aa992db773e277e064e706572ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177cdb8312158dcb068b364b14fbf323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a177cdb8312158dcb068b364b14fbf323">putVar</a> (const float *dataValues) const </td></tr>
<tr class="memdesc:a177cdb8312158dcb068b364b14fbf323"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a177cdb8312158dcb068b364b14fbf323">More...</a><br /></td></tr>
<tr class="separator:a177cdb8312158dcb068b364b14fbf323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fc130af91f1fdd2b32fcbe7eeb6a0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a74fc130af91f1fdd2b32fcbe7eeb6a0e">putVar</a> (const double *dataValues) const </td></tr>
<tr class="memdesc:a74fc130af91f1fdd2b32fcbe7eeb6a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a74fc130af91f1fdd2b32fcbe7eeb6a0e">More...</a><br /></td></tr>
<tr class="separator:a74fc130af91f1fdd2b32fcbe7eeb6a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50737a3446b65a914e373acd8c33e26a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a50737a3446b65a914e373acd8c33e26a">putVar</a> (const unsigned short *dataValues) const </td></tr>
<tr class="memdesc:a50737a3446b65a914e373acd8c33e26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a50737a3446b65a914e373acd8c33e26a">More...</a><br /></td></tr>
<tr class="separator:a50737a3446b65a914e373acd8c33e26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa869f9966c60bdffac49bb4959aac7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aaa869f9966c60bdffac49bb4959aac7f">putVar</a> (const unsigned int *dataValues) const </td></tr>
<tr class="memdesc:aaa869f9966c60bdffac49bb4959aac7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aaa869f9966c60bdffac49bb4959aac7f">More...</a><br /></td></tr>
<tr class="separator:aaa869f9966c60bdffac49bb4959aac7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda5fbc1ce6b4f50d8428b0e1551feb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#adda5fbc1ce6b4f50d8428b0e1551feb2">putVar</a> (const unsigned long long *dataValues) const </td></tr>
<tr class="memdesc:adda5fbc1ce6b4f50d8428b0e1551feb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#adda5fbc1ce6b4f50d8428b0e1551feb2">More...</a><br /></td></tr>
<tr class="separator:adda5fbc1ce6b4f50d8428b0e1551feb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a867f4b3d378f01e79c0953fac35c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ab0a867f4b3d378f01e79c0953fac35c2">putVar</a> (const long long *dataValues) const </td></tr>
<tr class="memdesc:ab0a867f4b3d378f01e79c0953fac35c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the entire data into the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable.  <a href="#ab0a867f4b3d378f01e79c0953fac35c2">More...</a><br /></td></tr>
<tr class="separator:ab0a867f4b3d378f01e79c0953fac35c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cb7c930fba5ebf4e726cbce491b16c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a16cb7c930fba5ebf4e726cbce491b16c">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const void *datumValue) const </td></tr>
<tr class="memdesc:a16cb7c930fba5ebf4e726cbce491b16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience.  <a href="#a16cb7c930fba5ebf4e726cbce491b16c">More...</a><br /></td></tr>
<tr class="separator:a16cb7c930fba5ebf4e726cbce491b16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae312b5c2c5c76d889ec614d1b9f16651"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ae312b5c2c5c76d889ec614d1b9f16651">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const char **datumValue) const </td></tr>
<tr class="memdesc:ae312b5c2c5c76d889ec614d1b9f16651"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ae312b5c2c5c76d889ec614d1b9f16651">More...</a><br /></td></tr>
<tr class="separator:ae312b5c2c5c76d889ec614d1b9f16651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca6ecbc32ddc0294e475e2742229239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a7ca6ecbc32ddc0294e475e2742229239">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const std::string &amp;datumValue) const </td></tr>
<tr class="memdesc:a7ca6ecbc32ddc0294e475e2742229239"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a7ca6ecbc32ddc0294e475e2742229239">More...</a><br /></td></tr>
<tr class="separator:a7ca6ecbc32ddc0294e475e2742229239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3b0044d879f96ea4fff07722e389f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a4e3b0044d879f96ea4fff07722e389f2">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const unsigned char *datumValue) const </td></tr>
<tr class="memdesc:a4e3b0044d879f96ea4fff07722e389f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a4e3b0044d879f96ea4fff07722e389f2">More...</a><br /></td></tr>
<tr class="separator:a4e3b0044d879f96ea4fff07722e389f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb318e6069e359ad80c4c458b6da32b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a9cb318e6069e359ad80c4c458b6da32b">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const signed char *datumValue) const </td></tr>
<tr class="memdesc:a9cb318e6069e359ad80c4c458b6da32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a9cb318e6069e359ad80c4c458b6da32b">More...</a><br /></td></tr>
<tr class="separator:a9cb318e6069e359ad80c4c458b6da32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea02c1e72af2935656904e254bac8450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aea02c1e72af2935656904e254bac8450">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const short datumValue) const </td></tr>
<tr class="memdesc:aea02c1e72af2935656904e254bac8450"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aea02c1e72af2935656904e254bac8450">More...</a><br /></td></tr>
<tr class="separator:aea02c1e72af2935656904e254bac8450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a7836b7c69a3f4629154909b774fe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a56a7836b7c69a3f4629154909b774fe2">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const int datumValue) const </td></tr>
<tr class="memdesc:a56a7836b7c69a3f4629154909b774fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a56a7836b7c69a3f4629154909b774fe2">More...</a><br /></td></tr>
<tr class="separator:a56a7836b7c69a3f4629154909b774fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e8c1b9ebe55fa2e8a44689724c2b2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a41e8c1b9ebe55fa2e8a44689724c2b2a">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const long datumValue) const </td></tr>
<tr class="memdesc:a41e8c1b9ebe55fa2e8a44689724c2b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a41e8c1b9ebe55fa2e8a44689724c2b2a">More...</a><br /></td></tr>
<tr class="separator:a41e8c1b9ebe55fa2e8a44689724c2b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9b27b1960baffb53fe2613110aadb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a9b9b27b1960baffb53fe2613110aadb4">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const float datumValue) const </td></tr>
<tr class="memdesc:a9b9b27b1960baffb53fe2613110aadb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a9b9b27b1960baffb53fe2613110aadb4">More...</a><br /></td></tr>
<tr class="separator:a9b9b27b1960baffb53fe2613110aadb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19b329255a4875428213e28133ebb63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ae19b329255a4875428213e28133ebb63">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const double datumValue) const </td></tr>
<tr class="memdesc:ae19b329255a4875428213e28133ebb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ae19b329255a4875428213e28133ebb63">More...</a><br /></td></tr>
<tr class="separator:ae19b329255a4875428213e28133ebb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a497ca223b9b208ee0b721a5a13a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#af4a497ca223b9b208ee0b721a5a13a77">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const unsigned short datumValue) const </td></tr>
<tr class="memdesc:af4a497ca223b9b208ee0b721a5a13a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#af4a497ca223b9b208ee0b721a5a13a77">More...</a><br /></td></tr>
<tr class="separator:af4a497ca223b9b208ee0b721a5a13a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9635fc9f885ed2720af80469a2b1b18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ac9635fc9f885ed2720af80469a2b1b18">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const unsigned int datumValue) const </td></tr>
<tr class="memdesc:ac9635fc9f885ed2720af80469a2b1b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ac9635fc9f885ed2720af80469a2b1b18">More...</a><br /></td></tr>
<tr class="separator:ac9635fc9f885ed2720af80469a2b1b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116d4113f7988571fb33e776cbb22cb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a116d4113f7988571fb33e776cbb22cb2">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const unsigned long long datumValue) const </td></tr>
<tr class="memdesc:a116d4113f7988571fb33e776cbb22cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a116d4113f7988571fb33e776cbb22cb2">More...</a><br /></td></tr>
<tr class="separator:a116d4113f7988571fb33e776cbb22cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b88daf90520bcc5b838d717638e0021"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a7b88daf90520bcc5b838d717638e0021">putVar</a> (const std::vector&lt; size_t &gt; &amp;index, const long long datumValue) const </td></tr>
<tr class="memdesc:a7b88daf90520bcc5b838d717638e0021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a single datum into the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable.  <a href="#a7b88daf90520bcc5b838d717638e0021">More...</a><br /></td></tr>
<tr class="separator:a7b88daf90520bcc5b838d717638e0021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11b9a43ef0064e005055c1bea735f02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ac11b9a43ef0064e005055c1bea735f02">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const void *dataValues) const </td></tr>
<tr class="memdesc:ac11b9a43ef0064e005055c1bea735f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience.  <a href="#ac11b9a43ef0064e005055c1bea735f02">More...</a><br /></td></tr>
<tr class="separator:ac11b9a43ef0064e005055c1bea735f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad540d036f57f72ecac5766fde0716044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad540d036f57f72ecac5766fde0716044">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const char **dataValues) const </td></tr>
<tr class="memdesc:ad540d036f57f72ecac5766fde0716044"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad540d036f57f72ecac5766fde0716044">More...</a><br /></td></tr>
<tr class="separator:ad540d036f57f72ecac5766fde0716044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb15cdcd383bd90809fa04429d8ed2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a9cb15cdcd383bd90809fa04429d8ed2b">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const char *dataValues) const </td></tr>
<tr class="memdesc:a9cb15cdcd383bd90809fa04429d8ed2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a9cb15cdcd383bd90809fa04429d8ed2b">More...</a><br /></td></tr>
<tr class="separator:a9cb15cdcd383bd90809fa04429d8ed2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5457490c3a1e2613959a3b0e1e70d8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ac5457490c3a1e2613959a3b0e1e70d8e">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const unsigned char *dataValues) const </td></tr>
<tr class="memdesc:ac5457490c3a1e2613959a3b0e1e70d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ac5457490c3a1e2613959a3b0e1e70d8e">More...</a><br /></td></tr>
<tr class="separator:ac5457490c3a1e2613959a3b0e1e70d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb3f1a2322d943ea78d568199044413"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aeeb3f1a2322d943ea78d568199044413">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const signed char *dataValues) const </td></tr>
<tr class="memdesc:aeeb3f1a2322d943ea78d568199044413"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aeeb3f1a2322d943ea78d568199044413">More...</a><br /></td></tr>
<tr class="separator:aeeb3f1a2322d943ea78d568199044413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efa486cafa05f28414a15376c8b260c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a9efa486cafa05f28414a15376c8b260c">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const short *dataValues) const </td></tr>
<tr class="memdesc:a9efa486cafa05f28414a15376c8b260c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a9efa486cafa05f28414a15376c8b260c">More...</a><br /></td></tr>
<tr class="separator:a9efa486cafa05f28414a15376c8b260c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21dcd0ef6fabb660078b5a5e01d4aceb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a21dcd0ef6fabb660078b5a5e01d4aceb">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const int *dataValues) const </td></tr>
<tr class="memdesc:a21dcd0ef6fabb660078b5a5e01d4aceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a21dcd0ef6fabb660078b5a5e01d4aceb">More...</a><br /></td></tr>
<tr class="separator:a21dcd0ef6fabb660078b5a5e01d4aceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae385e9be2176b452484e933089e67316"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ae385e9be2176b452484e933089e67316">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const long *dataValues) const </td></tr>
<tr class="memdesc:ae385e9be2176b452484e933089e67316"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ae385e9be2176b452484e933089e67316">More...</a><br /></td></tr>
<tr class="separator:ae385e9be2176b452484e933089e67316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76108f380c2dab5acb3bd80b37da856f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a76108f380c2dab5acb3bd80b37da856f">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const float *dataValues) const </td></tr>
<tr class="memdesc:a76108f380c2dab5acb3bd80b37da856f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a76108f380c2dab5acb3bd80b37da856f">More...</a><br /></td></tr>
<tr class="separator:a76108f380c2dab5acb3bd80b37da856f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763b0a2d6665ac22ab1be21b8b39c102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a763b0a2d6665ac22ab1be21b8b39c102">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const double *dataValues) const </td></tr>
<tr class="memdesc:a763b0a2d6665ac22ab1be21b8b39c102"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a763b0a2d6665ac22ab1be21b8b39c102">More...</a><br /></td></tr>
<tr class="separator:a763b0a2d6665ac22ab1be21b8b39c102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c7a83399d39f19dc36b5eff7346d33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a27c7a83399d39f19dc36b5eff7346d33">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const unsigned short *dataValues) const </td></tr>
<tr class="memdesc:a27c7a83399d39f19dc36b5eff7346d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a27c7a83399d39f19dc36b5eff7346d33">More...</a><br /></td></tr>
<tr class="separator:a27c7a83399d39f19dc36b5eff7346d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e71b8c076cc50a0df42ede288126f25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a0e71b8c076cc50a0df42ede288126f25">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const unsigned int *dataValues) const </td></tr>
<tr class="memdesc:a0e71b8c076cc50a0df42ede288126f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a0e71b8c076cc50a0df42ede288126f25">More...</a><br /></td></tr>
<tr class="separator:a0e71b8c076cc50a0df42ede288126f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e5f0d6c4a41d2eaebd53bac5bd12d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aa0e5f0d6c4a41d2eaebd53bac5bd12d6">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const unsigned long long *dataValues) const </td></tr>
<tr class="memdesc:aa0e5f0d6c4a41d2eaebd53bac5bd12d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aa0e5f0d6c4a41d2eaebd53bac5bd12d6">More...</a><br /></td></tr>
<tr class="separator:aa0e5f0d6c4a41d2eaebd53bac5bd12d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85917e3d98ddefbe57f16b3aa001afc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a85917e3d98ddefbe57f16b3aa001afc8">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const long long *dataValues) const </td></tr>
<tr class="memdesc:a85917e3d98ddefbe57f16b3aa001afc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an array of values into the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable.  <a href="#a85917e3d98ddefbe57f16b3aa001afc8">More...</a><br /></td></tr>
<tr class="separator:a85917e3d98ddefbe57f16b3aa001afc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5791a9465de08041995216f53e1f7c2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a5791a9465de08041995216f53e1f7c2f">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const void *dataValues) const </td></tr>
<tr class="memdesc:a5791a9465de08041995216f53e1f7c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience.  <a href="#a5791a9465de08041995216f53e1f7c2f">More...</a><br /></td></tr>
<tr class="separator:a5791a9465de08041995216f53e1f7c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3127cd1a4bffd82345663dd9fa56c303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a3127cd1a4bffd82345663dd9fa56c303">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const char **dataValues) const </td></tr>
<tr class="memdesc:a3127cd1a4bffd82345663dd9fa56c303"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a3127cd1a4bffd82345663dd9fa56c303">More...</a><br /></td></tr>
<tr class="separator:a3127cd1a4bffd82345663dd9fa56c303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd689020652db39fe7e192945456ff4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a2cd689020652db39fe7e192945456ff4">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const char *dataValues) const </td></tr>
<tr class="memdesc:a2cd689020652db39fe7e192945456ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a2cd689020652db39fe7e192945456ff4">More...</a><br /></td></tr>
<tr class="separator:a2cd689020652db39fe7e192945456ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad901b940d682607563c3841949d123e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad901b940d682607563c3841949d123e2">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const unsigned char *dataValues) const </td></tr>
<tr class="memdesc:ad901b940d682607563c3841949d123e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad901b940d682607563c3841949d123e2">More...</a><br /></td></tr>
<tr class="separator:ad901b940d682607563c3841949d123e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a1df030c369c504bc3c89af1cf95de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a06a1df030c369c504bc3c89af1cf95de">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const signed char *dataValues) const </td></tr>
<tr class="memdesc:a06a1df030c369c504bc3c89af1cf95de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a06a1df030c369c504bc3c89af1cf95de">More...</a><br /></td></tr>
<tr class="separator:a06a1df030c369c504bc3c89af1cf95de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6814394c25d2aa56dc4dabd6c60b54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a2b6814394c25d2aa56dc4dabd6c60b54">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const short *dataValues) const </td></tr>
<tr class="memdesc:a2b6814394c25d2aa56dc4dabd6c60b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a2b6814394c25d2aa56dc4dabd6c60b54">More...</a><br /></td></tr>
<tr class="separator:a2b6814394c25d2aa56dc4dabd6c60b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098349114f8007379eb2dacc1bac5fd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a098349114f8007379eb2dacc1bac5fd4">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const int *dataValues) const </td></tr>
<tr class="memdesc:a098349114f8007379eb2dacc1bac5fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a098349114f8007379eb2dacc1bac5fd4">More...</a><br /></td></tr>
<tr class="separator:a098349114f8007379eb2dacc1bac5fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0007e66fbbc9edc2225f861221809b6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a0007e66fbbc9edc2225f861221809b6d">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const long *dataValues) const </td></tr>
<tr class="memdesc:a0007e66fbbc9edc2225f861221809b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a0007e66fbbc9edc2225f861221809b6d">More...</a><br /></td></tr>
<tr class="separator:a0007e66fbbc9edc2225f861221809b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8065c5284c5b0766762379ccb48183e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#af8065c5284c5b0766762379ccb48183e">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const float *dataValues) const </td></tr>
<tr class="memdesc:af8065c5284c5b0766762379ccb48183e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#af8065c5284c5b0766762379ccb48183e">More...</a><br /></td></tr>
<tr class="separator:af8065c5284c5b0766762379ccb48183e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad979d641bc1287023a259eaf96e0c187"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ad979d641bc1287023a259eaf96e0c187">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const double *dataValues) const </td></tr>
<tr class="memdesc:ad979d641bc1287023a259eaf96e0c187"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad979d641bc1287023a259eaf96e0c187">More...</a><br /></td></tr>
<tr class="separator:ad979d641bc1287023a259eaf96e0c187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b063d6a941b2a868cdbe17cc927e577"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a1b063d6a941b2a868cdbe17cc927e577">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const unsigned short *dataValues) const </td></tr>
<tr class="memdesc:a1b063d6a941b2a868cdbe17cc927e577"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a1b063d6a941b2a868cdbe17cc927e577">More...</a><br /></td></tr>
<tr class="separator:a1b063d6a941b2a868cdbe17cc927e577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51c0722f9a99befdc5a7467c059eea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aa51c0722f9a99befdc5a7467c059eea4">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const unsigned int *dataValues) const </td></tr>
<tr class="memdesc:aa51c0722f9a99befdc5a7467c059eea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aa51c0722f9a99befdc5a7467c059eea4">More...</a><br /></td></tr>
<tr class="separator:aa51c0722f9a99befdc5a7467c059eea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003c7c020ab5f00c6be72cc2d320c027"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a003c7c020ab5f00c6be72cc2d320c027">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const unsigned long long *dataValues) const </td></tr>
<tr class="memdesc:a003c7c020ab5f00c6be72cc2d320c027"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a003c7c020ab5f00c6be72cc2d320c027">More...</a><br /></td></tr>
<tr class="separator:a003c7c020ab5f00c6be72cc2d320c027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5847afc22338614a8885d7a8654ae11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aa5847afc22338614a8885d7a8654ae11">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const long long *dataValues) const </td></tr>
<tr class="memdesc:aa5847afc22338614a8885d7a8654ae11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an array of values into the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable.  <a href="#aa5847afc22338614a8885d7a8654ae11">More...</a><br /></td></tr>
<tr class="separator:aa5847afc22338614a8885d7a8654ae11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4a231f4b9385ef346d4cebf869f13a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a3f4a231f4b9385ef346d4cebf869f13a">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const void *dataValues) const </td></tr>
<tr class="memdesc:a3f4a231f4b9385ef346d4cebf869f13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience.  <a href="#a3f4a231f4b9385ef346d4cebf869f13a">More...</a><br /></td></tr>
<tr class="separator:a3f4a231f4b9385ef346d4cebf869f13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f24f65c150c12fc31fc1f066d8dee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ae5f24f65c150c12fc31fc1f066d8dee2">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const char **dataValues) const </td></tr>
<tr class="memdesc:ae5f24f65c150c12fc31fc1f066d8dee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ae5f24f65c150c12fc31fc1f066d8dee2">More...</a><br /></td></tr>
<tr class="separator:ae5f24f65c150c12fc31fc1f066d8dee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6373ec61b53209f3246874d0839c8d52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a6373ec61b53209f3246874d0839c8d52">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const char *dataValues) const </td></tr>
<tr class="memdesc:a6373ec61b53209f3246874d0839c8d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a6373ec61b53209f3246874d0839c8d52">More...</a><br /></td></tr>
<tr class="separator:a6373ec61b53209f3246874d0839c8d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd16d9c72ea9e8c014e16f7961c09ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#afdd16d9c72ea9e8c014e16f7961c09ee">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const unsigned char *dataValues) const </td></tr>
<tr class="memdesc:afdd16d9c72ea9e8c014e16f7961c09ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#afdd16d9c72ea9e8c014e16f7961c09ee">More...</a><br /></td></tr>
<tr class="separator:afdd16d9c72ea9e8c014e16f7961c09ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21606e1c6f31d7889b94070c37bb868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ab21606e1c6f31d7889b94070c37bb868">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const signed char *dataValues) const </td></tr>
<tr class="memdesc:ab21606e1c6f31d7889b94070c37bb868"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ab21606e1c6f31d7889b94070c37bb868">More...</a><br /></td></tr>
<tr class="separator:ab21606e1c6f31d7889b94070c37bb868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac978eb02324a9cbd0d3416c3a46574d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ac978eb02324a9cbd0d3416c3a46574d8">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const short *dataValues) const </td></tr>
<tr class="memdesc:ac978eb02324a9cbd0d3416c3a46574d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ac978eb02324a9cbd0d3416c3a46574d8">More...</a><br /></td></tr>
<tr class="separator:ac978eb02324a9cbd0d3416c3a46574d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29fe35f6fb657c6f6fa883ad9c30cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ab29fe35f6fb657c6f6fa883ad9c30cdc">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const int *dataValues) const </td></tr>
<tr class="memdesc:ab29fe35f6fb657c6f6fa883ad9c30cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ab29fe35f6fb657c6f6fa883ad9c30cdc">More...</a><br /></td></tr>
<tr class="separator:ab29fe35f6fb657c6f6fa883ad9c30cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348f092cf821bd14e123fb446eeec96a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a348f092cf821bd14e123fb446eeec96a">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const long *dataValues) const </td></tr>
<tr class="memdesc:a348f092cf821bd14e123fb446eeec96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a348f092cf821bd14e123fb446eeec96a">More...</a><br /></td></tr>
<tr class="separator:a348f092cf821bd14e123fb446eeec96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406d7e26e8e065f68ee35353b8172c89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a406d7e26e8e065f68ee35353b8172c89">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const float *dataValues) const </td></tr>
<tr class="memdesc:a406d7e26e8e065f68ee35353b8172c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a406d7e26e8e065f68ee35353b8172c89">More...</a><br /></td></tr>
<tr class="separator:a406d7e26e8e065f68ee35353b8172c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c560b3ef22c84a16d06ed0be299d5a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a3c560b3ef22c84a16d06ed0be299d5a5">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const double *dataValues) const </td></tr>
<tr class="memdesc:a3c560b3ef22c84a16d06ed0be299d5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a3c560b3ef22c84a16d06ed0be299d5a5">More...</a><br /></td></tr>
<tr class="separator:a3c560b3ef22c84a16d06ed0be299d5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d642dbf6b04d00c96bd414357981fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a43d642dbf6b04d00c96bd414357981fb">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const unsigned short *dataValues) const </td></tr>
<tr class="memdesc:a43d642dbf6b04d00c96bd414357981fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a43d642dbf6b04d00c96bd414357981fb">More...</a><br /></td></tr>
<tr class="separator:a43d642dbf6b04d00c96bd414357981fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed905a5afbaffe9f2ead0f6f1b9fd977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aed905a5afbaffe9f2ead0f6f1b9fd977">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const unsigned int *dataValues) const </td></tr>
<tr class="memdesc:aed905a5afbaffe9f2ead0f6f1b9fd977"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aed905a5afbaffe9f2ead0f6f1b9fd977">More...</a><br /></td></tr>
<tr class="separator:aed905a5afbaffe9f2ead0f6f1b9fd977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8983e6b481aa26725b40797f9ca6c13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ae8983e6b481aa26725b40797f9ca6c13">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const unsigned long long *dataValues) const </td></tr>
<tr class="memdesc:ae8983e6b481aa26725b40797f9ca6c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ae8983e6b481aa26725b40797f9ca6c13">More...</a><br /></td></tr>
<tr class="separator:ae8983e6b481aa26725b40797f9ca6c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8388b7c786eace3bbefadfcad5e10d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ab8388b7c786eace3bbefadfcad5e10d7">putVar</a> (const std::vector&lt; size_t &gt; &amp;startp, const std::vector&lt; size_t &gt; &amp;countp, const std::vector&lt; ptrdiff_t &gt; &amp;stridep, const std::vector&lt; ptrdiff_t &gt; &amp;imapp, const long long *dataValues) const </td></tr>
<tr class="memdesc:ab8388b7c786eace3bbefadfcad5e10d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a mapped array section of values into the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable.  <a href="#ab8388b7c786eace3bbefadfcad5e10d7">More...</a><br /></td></tr>
<tr class="separator:ab8388b7c786eace3bbefadfcad5e10d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7962371f921a2003261c9156a8c10661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a7962371f921a2003261c9156a8c10661">rename</a> (const std::string &amp;newname) const </td></tr>
<tr class="memdesc:a7962371f921a2003261c9156a8c10661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename the variable.  <a href="#a7962371f921a2003261c9156a8c10661">More...</a><br /></td></tr>
<tr class="separator:a7962371f921a2003261c9156a8c10661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b89cc33bd3ab564c023e5620c0f4db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a92b89cc33bd3ab564c023e5620c0f4db">setChecksum</a> (<a class="el" href="classnetCDF_1_1NcVar.html#a6fa17911a9f7ec09cc05e34bc4f63a39">ChecksumMode</a> checksumMode) const </td></tr>
<tr class="memdesc:a92b89cc33bd3ab564c023e5620c0f4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the checksum parameters of a variable.  <a href="#a92b89cc33bd3ab564c023e5620c0f4db">More...</a><br /></td></tr>
<tr class="separator:a92b89cc33bd3ab564c023e5620c0f4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d0550ce2b4874e27e443467801d5b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a02d0550ce2b4874e27e443467801d5b0">setChunking</a> (<a class="el" href="classnetCDF_1_1NcVar.html#a1e8425b2967665ab83f1e76abac2a76a">ChunkMode</a> chunkMode, std::vector&lt; size_t &gt; &amp;chunksizes) const </td></tr>
<tr class="memdesc:a02d0550ce2b4874e27e443467801d5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets chunking parameters.  <a href="#a02d0550ce2b4874e27e443467801d5b0">More...</a><br /></td></tr>
<tr class="separator:a02d0550ce2b4874e27e443467801d5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69eb657938c93ce61c545625c338fa09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a69eb657938c93ce61c545625c338fa09">setCompression</a> (bool enableShuffleFilter, bool enableDeflateFilter, int deflateLevel) const </td></tr>
<tr class="memdesc:a69eb657938c93ce61c545625c338fa09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the compression parameters.  <a href="#a69eb657938c93ce61c545625c338fa09">More...</a><br /></td></tr>
<tr class="separator:a69eb657938c93ce61c545625c338fa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429f38087cc007c8d6f947e1b4fab41d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a429f38087cc007c8d6f947e1b4fab41d">setEndianness</a> (<a class="el" href="classnetCDF_1_1NcVar.html#ad6e882d6cc8aa698ef82b96e14eaa7a9">EndianMode</a> endianMode) const </td></tr>
<tr class="memdesc:a429f38087cc007c8d6f947e1b4fab41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the endianness of the variable.  <a href="#a429f38087cc007c8d6f947e1b4fab41d">More...</a><br /></td></tr>
<tr class="separator:a429f38087cc007c8d6f947e1b4fab41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148c942970df9692406406c674341ad7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#a148c942970df9692406406c674341ad7">setFill</a> (bool fillMode, void *fillValue=NULL) const </td></tr>
<tr class="memdesc:a148c942970df9692406406c674341ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a148c942970df9692406406c674341ad7">More...</a><br /></td></tr>
<tr class="separator:a148c942970df9692406406c674341ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8817f6ab44699ca5e83acf97d6e2c61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ae8817f6ab44699ca5e83acf97d6e2c61">setFill</a> (bool fillMode, const void *fillValue=NULL) const </td></tr>
<tr class="memdesc:ae8817f6ab44699ca5e83acf97d6e2c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience.  <a href="#ae8817f6ab44699ca5e83acf97d6e2c61">More...</a><br /></td></tr>
<tr class="separator:ae8817f6ab44699ca5e83acf97d6e2c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af911b1164ee5664b59740e6785661213"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af911b1164ee5664b59740e6785661213"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#af911b1164ee5664b59740e6785661213">setFill</a> (bool fillMode, T fillValue) const </td></tr>
<tr class="memdesc:af911b1164ee5664b59740e6785661213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fill parameters.  <a href="#af911b1164ee5664b59740e6785661213">More...</a><br /></td></tr>
<tr class="separator:af911b1164ee5664b59740e6785661213"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aed6a3f330998706e012532a66ae4dd00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#aed6a3f330998706e012532a66ae4dd00">operator&lt;</a> (const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;lhs, const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;rhs)</td></tr>
<tr class="memdesc:aed6a3f330998706e012532a66ae4dd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparator operator  <a href="#aed6a3f330998706e012532a66ae4dd00">More...</a><br /></td></tr>
<tr class="separator:aed6a3f330998706e012532a66ae4dd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5193f5190c50d693489bb3fdbe36a08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetCDF_1_1NcVar.html#ac5193f5190c50d693489bb3fdbe36a08">operator&gt;</a> (const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;lhs, const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;rhs)</td></tr>
<tr class="memdesc:ac5193f5190c50d693489bb3fdbe36a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparator operator  <a href="#ac5193f5190c50d693489bb3fdbe36a08">More...</a><br /></td></tr>
<tr class="separator:ac5193f5190c50d693489bb3fdbe36a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class represents a <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. </p>

<p>Definition at line <a class="el" href="ncVar_8h_source.html#l00033">33</a> of file <a class="el" href="ncVar_8h_source.html">ncVar.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a6fa17911a9f7ec09cc05e34bc4f63a39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnetCDF_1_1NcVar.html#a6fa17911a9f7ec09cc05e34bc4f63a39">netCDF::NcVar::ChecksumMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for checksum specification (see <a class="el" href="classnetCDF_1_1NcVar.html#a92b89cc33bd3ab564c023e5620c0f4db" title="Sets the checksum parameters of a variable. ">NcVar::setChecksum</a>, <a class="el" href="classnetCDF_1_1NcVar.html#a38b5f4f38dde165aebfe7e61d0f4e3c0" title="Gets the checksum parameters of the variable. ">NcVar::getChecksum</a>). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a6fa17911a9f7ec09cc05e34bc4f63a39afc8c54af8efa1a65beb0ec52ad0de4ed"></a>nc_NOCHECKSUM&#160;</td><td class="fielddoc">
<p>No checksum (the default). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6fa17911a9f7ec09cc05e34bc4f63a39a2098bffc0ca08276e8252847cf3ec269"></a>nc_FLETCHER32&#160;</td><td class="fielddoc">
<p>Selects the Fletcher32 checksum filter. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="ncVar_8h_source.html#l00062">62</a> of file <a class="el" href="ncVar_8h_source.html">ncVar.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1e8425b2967665ab83f1e76abac2a76a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnetCDF_1_1NcVar.html#a1e8425b2967665ab83f1e76abac2a76a">netCDF::NcVar::ChunkMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for chunking specifications (see <a class="el" href="classnetCDF_1_1NcVar.html#a02d0550ce2b4874e27e443467801d5b0" title="Sets chunking parameters. ">NcVar::setChunking</a>, <a class="el" href="classnetCDF_1_1NcVar.html#a4b267cf0903e6bca4493c2e4360aed00" title="Gets the chunking parameters. ">NcVar::getChunkingParameters</a>). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a1e8425b2967665ab83f1e76abac2a76aa19d35fac1f574de8f0036a43cc2cc32f"></a>nc_CHUNKED&#160;</td><td class="fielddoc">
<p>Chunked storage is used for this variable. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1e8425b2967665ab83f1e76abac2a76aa254599ed4575a7b58af3880b9ff66d15"></a>nc_CONTIGUOUS&#160;</td><td class="fielddoc">
<p>Contiguous storage is used for this variable. </p>
<p>Variables with one or more unlimited dimensions cannot use contiguous storage. If contiguous storage is turned on, the chunkSizes parameter is ignored. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="ncVar_8h_source.html#l00038">38</a> of file <a class="el" href="ncVar_8h_source.html">ncVar.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad6e882d6cc8aa698ef82b96e14eaa7a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnetCDF_1_1NcVar.html#ad6e882d6cc8aa698ef82b96e14eaa7a9">netCDF::NcVar::EndianMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to specifying the endianess of the data, (see <a class="el" href="classnetCDF_1_1NcVar.html#a429f38087cc007c8d6f947e1b4fab41d" title="Sets the endianness of the variable. ">NcVar::setEndianness</a>, <a class="el" href="classnetCDF_1_1NcVar.html#a4b8f11bc557205faed4144ea57e9ba1a" title="Gets the endianness of the variable. ">NcVar::getEndianness</a>). </p>
<p>By default this is NC_ENDIAN_NATIVE. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ad6e882d6cc8aa698ef82b96e14eaa7a9aa2313d7f36e771ad255cbec9100a720c"></a>nc_ENDIAN_NATIVE&#160;</td><td class="fielddoc">
<p>Native endian. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad6e882d6cc8aa698ef82b96e14eaa7a9ae0c178e332e7b749f5c60f301f5d666f"></a>nc_ENDIAN_LITTLE&#160;</td><td class="fielddoc">
<p>Little endian. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad6e882d6cc8aa698ef82b96e14eaa7a9a8ce7fd59a740013d5b7472c8c88f1fbe"></a>nc_ENDIAN_BIG&#160;</td><td class="fielddoc">
<p>Big endian. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="ncVar_8h_source.html#l00054">54</a> of file <a class="el" href="ncVar_8h_source.html">ncVar.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a764d808db44c8071ea177f8f9fbae04c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">netCDF::NcVar::~NcVar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>

<p>Definition at line <a class="el" href="ncVar_8h_source.html#l00069">69</a> of file <a class="el" href="ncVar_8h_source.html">ncVar.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab4aa88742d17f4cba10346eaf53a9c98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NcVar::NcVar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor generates a <a class="el" href="classnetCDF_1_1NcVar.html#abff3856710bf8ea8ddc4a01b52a61c88">null object</a>. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00065">65</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ccae6d56922c7eaf4634e43e308dad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NcVar::NcVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcGroup.html">NcGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>varId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for a variable . </p>
<p>The variable must already exist in the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> file. New <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variables can be added using NcGroup::addNcVar(); </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp</td><td>Parent <a class="el" href="classnetCDF_1_1NcGroup.html" title="Class represents a netCDF group. ">NcGroup</a> object. </td></tr>
    <tr><td class="paramname">varId</td><td>Id of the is <a class="el" href="classnetCDF_1_1NcVar.html" title="Class represents a netCDF variable. ">NcVar</a> object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00071">71</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aea3d493b50196885972b698d9773b4c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NcVar::NcVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;&#160;</td>
          <td class="paramname"><em>ncVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The copy constructor. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00038">38</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acf4d6282ca2d01c9cb03107455eb4454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> NcVar::getAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets attribute by name. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00211">211</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac79fe3ecb29591ef213ea18a3142efd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NcVar::getAttCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of attributes. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00187">187</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae8041f272c7edf4ac74b979838bd099"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, <a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> &gt; NcVar::getAtts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the set of attributes. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00196">196</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38b5f4f38dde165aebfe7e61d0f4e3c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVar.html#a6fa17911a9f7ec09cc05e34bc4f63a39">NcVar::ChecksumMode</a> NcVar::getChecksum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the checksum parameters of the variable. </p>
<dl class="section return"><dt>Returns</dt><dd>ChecksumMode Enumeration type. Allowable parameters are: "nc_NOCHECKSUM", "nc_FLETCHER32". </dd></dl>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00667">667</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b267cf0903e6bca4493c2e4360aed00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getChunkingParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnetCDF_1_1NcVar.html#a1e8425b2967665ab83f1e76abac2a76a">ChunkMode</a> &amp;&#160;</td>
          <td class="paramname"><em>chunkMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>chunkSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the chunking parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunkMode</td><td>On return contains either: "nc_CONTIGUOUS" or "nc_CHUNKED" </td></tr>
    <tr><td class="paramname">chunksizes</td><td>On return contains shape of chunking, used if ChunkMode=nc_CHUNKED. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00550">550</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19c01b4329a1c9d7ed0cb3bd13c3848a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getCompressionParameters </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>shuffleFilterEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>deflateFilterEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>deflateLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the compression parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enableShuffleFilter</td><td>On return set to true if the shuffle filter is enabled. </td></tr>
    <tr><td class="paramname">enableDeflateFilter</td><td>On return set to true if the deflate filter is enabled. </td></tr>
    <tr><td class="paramname">deflateLevel</td><td>On return set to the deflate level. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00615">615</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae96cb42e88ca00095bd09d082057fdf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcDim.html">NcDim</a> NcVar::getDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the i'th <a class="el" href="classnetCDF_1_1NcDim.html" title="Class represents a netCDF dimension. ">NcDim</a> object. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00171">171</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65173b804ae50806ce1a4ee0a1cab698"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NcVar::getDimCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The the number of dimensions. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00142">142</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab952efcd760fd69b7b491732a3afdf5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classnetCDF_1_1NcDim.html">NcDim</a> &gt; NcVar::getDims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the set of <a class="el" href="classnetCDF_1_1NcDim.html" title="Class represents a netCDF dimension. ">NcDim</a> objects. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00151">151</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b8f11bc557205faed4144ea57e9ba1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVar.html#ad6e882d6cc8aa698ef82b96e14eaa7a9">NcVar::EndianMode</a> NcVar::getEndianness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the endianness of the variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Endianness enumeration type. Allowable parameters are: "nc_ENDIAN_NATIVE" (the default), "nc_ENDIAN_LITTLE", "nc_ENDIAN_BIG" </dd></dl>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00644">644</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb131a278d59c45cf18679eea0614c4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getFillModeParameters </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>fillMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fillValue</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. </p>
<p>It differs from the above function in what argument(s) it accepts. The function can be used for any type, including user-defined types. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillMode</td><td>On return set to true if fill mode is enabled. </td></tr>
    <tr><td class="paramname">fillValue</td><td>On return containts a pointer to fill value. Must be the same type as the variable. Ignored if fillMode=.false. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00585">585</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7130dddb05775fe542382ad146bb11f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getFillModeParameters </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>fillMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fill parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">On</td><td>return set to true if fill mode is enabled. </td></tr>
    <tr><td class="paramname">On</td><td>return is set to the fill value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ncVar_8h_source.html#l00314">314</a> of file <a class="el" href="ncVar_8h_source.html">ncVar.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8ccbfb2c9302452c7dddc7bfe59bf19b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NcVar::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the variable id. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00086">86</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80f1f355b78519cdbeca09f468b764b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string NcVar::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of this <a class="el" href="classnetCDF_1_1NcVar.html" title="Class represents a netCDF variable. ">NcVar</a> object. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00528">528</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa375e8a5af9245e053c91b9f3ba4af0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcGroup.html">NcGroup</a> NcVar::getParentGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets parent group. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00080">80</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a26cfe65ba5d48b32fa55b4c0c91bf1b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcType.html">NcType</a> NcVar::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the variable type. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00096">96</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acfb10fba7aa386e06551039bddd555c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. </p>
<p>It differs from the above function in what argument(s) it accepts. In addition, no data conversion is carried out. This means that the type of the data in memory must match the type of the variable. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01439">1439</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af861854a7c29a87de7cb101d78ad5dec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01431">1431</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1827de6e9a01eba0123ac2d3ea20eda5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01335">1335</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d971e3414b6d8d429b01ff90d5b9106"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01343">1343</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4fc01a0a27dc2aef4b611d4920a52ace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">signed char *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01351">1351</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5986aaa88aad5790935543f574eb9ed7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01359">1359</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a066f94d2debff11e04bd8330c629602a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01367">1367</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc031f1d34cca5dc8171894bfbd46310"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01375">1375</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc3232a3c0826689bb4b3dd62cb3e90f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01383">1383</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a269152bba0de2aa59abe82d38eec8dac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01391">1391</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f75ff3a384ecf824c91fa13dedb52e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01399">1399</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afdf545f6790e25b9f4bea3752ae168f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01407">1407</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66c7727ffa8f4d5f7d27ad1011d161a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">unsigned long long *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01423">1423</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1609dcb1106641201ddb606401f1ab93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the entire data from an <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. </p>
<p>This is the simplest interface to use for reading the value of a scalar variable or when all the values of a multidimensional variable can be read at once. The values are read into consecutive locations with the last dimension varying fastest.</p>
<p>Take care when using the simplest forms of this interface with record variables when you don't specify how many records are to be read. If you try to read all the values of a record variable into an array but there are more records in the file than you assume, more data will be read than you expect, which may cause a segmentation violation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataValues</td><td>Pointer to the location into which the data value is read. If the type of data value differs from the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable type, type conversion will occur. (However, no type conversion is carried out for variables using the user-defined data types: nc_Vlen, nc_Opaque, nc_Compound and nc_Enum.) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l01415">1415</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f82edf52e3c47254bb48f6c689732ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. </p>
<p>It differs from the above function in what argument(s) it accepts. In addition, no data conversion is carried out. This means that the type of the data in memory must match the type of the variable. </p>

</div>
</div>
<a class="anchor" id="aff9ebc6606de80f763142b2d8a347de2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a05e3c80d428bcec834c87cd7853b5f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a51c03b9f2dcb2e7e945a4f8e618bd158"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a308342b38312462b197bd25accf0deba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a4e4656747476e6e2053b58b8bab412b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="abab308dabaf2e507e5a62166777e983b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a398c167ae0cc994208b61b2422bf2ea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="adf05266166de1bec4d1283390d358e26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a467fcb92064bb9067ef9da116b0f93a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad2e84fe7fec3c38023a93927c5f5763c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aac88e260332e4316f956cb66b7f947a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad25ef840aa5d8c563245c568a5333d88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a7349b33cb8e7b246c3acdc4bd575266d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a single datum value from a variable of an open <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> dataset. </p>
<p>The value is converted from the external data type of the variable, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Vector specifying the index of the data value to be read. The indices are relative to 0, so for example, the first data value of a two-dimensional variable would have index (0,0). The elements of index must correspond to the variable's dimensions. Hence, if the variable is a record variable, the first index is the record number.</td></tr>
    <tr><td class="paramname">datumValue</td><td>Pointer to the location into which the data value is read. If the type of data value differs from the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable type, type conversion will occur. (However, no type conversion is carried out for variables using the user-defined data types: nc_Vlen, nc_Opaque, nc_Compound and nc_Enum.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2951947e67ba1d76a9da6929f155dd38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. </p>
<p>It differs from the above function in what argument(s) it accepts. In addition, no data conversion is carried out. This means that the type of the data in memory must match the type of the variable. </p>

</div>
</div>
<a class="anchor" id="a5de17f990c78ccdd83121392d02c446a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a4f74c300f50b34ea366f54d224a3968a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ab0edb01b9c97a58f587a4f0e72aeb868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a92a1a8ad763b337518cbca19d4c48150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="abf75223a926d65f8bef7a68c60ba02bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ae935f8bd822cd9f17cec7b66b9910941"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad8333c4c1cf16636dea144eae2a6b30c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a54943eb6861471d3eef366d81958153e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a74d273a0d5f572d04b78c92cd0f5d41b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="afd98af4a70384b9f4fe5524dc08ee40c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="abc576e42235ddd131db9c382de4a9ebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a659859a9afba4c9f9795402b9ba8752e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a66f88dcaab7fc497f861c6080e7cbff9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of values from a <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable of an open <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> dataset. </p>
<p>The array is specified by giving a corner and a vector of edge lengths. The values are read into consecutive locations with the last dimension varying fastest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Vector specifying the index in the variable where the first of the data values will be read. The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0). The length of start must be the same as the number of dimensions of the specified variable. The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable, the first index would correspond to the starting record number for reading the data values.</td></tr>
    <tr><td class="paramname">count</td><td>Vector specifying the edge lengths along each dimension of the block of data values to be read. To read a single value, for example, specify count as (1, 1, ... , 1). The length of count is the number of dimensions of the specified variable. The elements of count correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to read. Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.</td></tr>
    <tr><td class="paramname">dataValues</td><td>Pointer to the location into which the data value is read. If the type of data value differs from the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable type, type conversion will occur. (However, no type conversion is carried out for variables using the user-defined data types: nc_Vlen, nc_Opaque, nc_Compound and nc_Enum.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67f73b5dee3d535e4e2aed3011c7dabf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. </p>
<p>It differs from the above function in what argument(s) it accepts. In addition, no data conversion is carried out. This means that the type of the data in memory must match the type of the variable. </p>

</div>
</div>
<a class="anchor" id="a12ff5ff744d149b82a75b3d900c8e817"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="afb89b43711305f03bc5e6548b949167b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aa8b06c60f4f569de7d89f9c4dcf1b52f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a26922664de4212378961be34acc5cb13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="abd7c569fb75a92b3f145e8eb4c3a376d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a1ecd56061917355fcdde3e90201c402f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac3a37a66216c366847cea2f7e9b527e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a8330e38aa414bd9308eda6bd481a23c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a2df0be1039713d3c37b6902dc0b67dfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="acbbeae65265387b284473a1a53c2c729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aca6bb27610ff15a01b83efc9c7426634"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a53449174ec25c443ae620b87e5b5e415"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="adecda6d270e5713fc5bea6a22306ae1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a subsampled (strided) array section of values from a <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. </p>
<p>The subsampled array section is specified by giving a corner, a vector of edge lengths, and a stride vector. The values are read with the last dimension of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable varying fastest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Vector specifying the index in the variable where the first of the data values will be read. The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0). The length of start must be the same as the number of dimensions of the specified variable. The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable, the first index would correspond to the starting record number for reading the data values.</td></tr>
    <tr><td class="paramname">count</td><td>Vector specifying the edge lengths along each dimension of the block of data values to be read. To read a single value, for example, specify count as (1, 1, ... , 1). The length of count is the number of dimensions of the specified variable. The elements of count correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to read. Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.</td></tr>
    <tr><td class="paramname">stride</td><td>Vector specifying the interval between selected indices. The elements of the stride vector correspond, in order, to the variable's dimensions. A value of 1 accesses adjacent values of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable in the corresponding dimension; a value of 2 accesses every other value of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable in the corresponding dimension; and so on. A NULL stride argument is treated as (1, 1, ... , 1).</td></tr>
    <tr><td class="paramname">dataValues</td><td>Pointer to the location into which the data value is read. If the type of data value differs from the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable type, type conversion will occur. (However, no type conversion is carried out for variables using the user-defined data types: nc_Vlen, nc_Opaque, nc_Compound and nc_Enum.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6f0a4f913ee85130fd9d89c910d9c05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. </p>
<p>It differs from the above function in what argument(s) it accepts. In addition, no data conversion is carried out. This means that the type of the data in memory must match the type of the variable. </p>

</div>
</div>
<a class="anchor" id="a3ae55bb18a426f1665931385c7ce1854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a6de0b6ec0b412d811cece5d70b7bf04d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad6bb5acc43b9c82a760ee8eb588f1c90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad83e3c6e12d538d49612758fae530b73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a43a0c9c468bec1a14e1ba0e1e6f6ab24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a19b70f5fe34fdd29f6de7e7f3edfb56e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac0f9f8d7741537022753a48acc66ab56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="af212b0f70aa24c5112187c4932ea3b2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aa0b5c6be93a66c80588356fd6b21ef42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a8cbb0ec2911f4fe1dc9a9abf498dc2c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a06d8035ff1ac2b032abcde98633cd941"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="af6e3c592cd79e7505bebb0197de3ab54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a8cc3e28ca5637d359da13aaf59e96cca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::getVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a mapped array section of values from a <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. </p>
<p>The mapped array section is specified by giving a corner, a vector of edge lengths, a stride vector, and an index mapping vector. The index mapping vector is a vector of integers that specifies the mapping between the dimensions of a <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable and the in-memory structure of the internal data array. No assumptions are made about the ordering or length of the dimensions of the data array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Vector specifying the index in the variable where the first of the data values will be read. The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0). The length of start must be the same as the number of dimensions of the specified variable. The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable, the first index would correspond to the starting record number for reading the data values.</td></tr>
    <tr><td class="paramname">count</td><td>Vector specifying the edge lengths along each dimension of the block of data values to be read. To read a single value, for example, specify count as (1, 1, ... , 1). The length of count is the number of dimensions of the specified variable. The elements of count correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to read. Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.</td></tr>
    <tr><td class="paramname">stride</td><td>Vector specifying the interval between selected indices. The elements of the stride vector correspond, in order, to the variable's dimensions. A value of 1 accesses adjacent values of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable in the corresponding dimension; a value of 2 accesses every other value of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable in the corresponding dimension; and so on. A NULL stride argument is treated as (1, 1, ... , 1).</td></tr>
    <tr><td class="paramname">imap</td><td>Vector of integers that specifies the mapping between the dimensions of a <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable and the in-memory structure of the internal data array. imap[0] gives the distance between elements of the internal array corresponding to the most slowly varying dimension of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. imap[n-1] (where n is the rank of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable) gives the distance between elements of the internal array corresponding to the most rapidly varying dimension of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. Intervening imap elements correspond to other dimensions of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable in the obvious way. Distances between elements are specified in type-independent units of elements (the distance between internal elements that occupy adjacent memory locations is 1 and not the element's byte-length as in <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> 2).</td></tr>
    <tr><td class="paramname">dataValues</td><td>Pointer to the location into which the data value is read. If the type of data value differs from the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable type, type conversion will occur. (However, no type conversion is carried out for variables using the user-defined data types: nc_Vlen, nc_Opaque, nc_Compound and nc_Enum.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abff3856710bf8ea8ddc4a01b52a61c88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool netCDF::NcVar::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this object variable is not defined. </p>

<p>Definition at line <a class="el" href="ncVar_8h_source.html#l00112">112</a> of file <a class="el" href="ncVar_8h_source.html">ncVar.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa90c14c2561e82c877ed6ce9bf147695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NcVar::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!= operator </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00053">53</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c667eccb01b705ff3e8869d0c0829ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp; NcVar::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assignment operator </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00029">29</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af71e9c962907c2eeb21197c3b2e2add8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NcVar::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>equivalence operator </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00046">46</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2881b1d3ed255179637e752367fca35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aaaee339673070d4648d515a104b2230d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a26e0ebea6d405754cff7ac12348bb1d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a1806cfa7e28ec71ad816c1609eb5ba9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const signed char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a5558749ec34f11e92634bde7bef6cbec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aa2a2ad2bcc7aa4d71f499c5db5a10329"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a5310e2a7e6d4e7ef38ccd65d900e7546"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad4469fef6f9625fc2504c5fbfeb5e034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aabb5d76a8dc83c5e9699f69b58bcd2ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a0287fe19cd8344edcab17c0c59fa2091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a97fe064c2ab7d62f47e77be881051c61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ab6eda7fc61fb6609e65719abf47621ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aaa51d0607796fe05b8de4e5a318a1d86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a0542684eb439ca17ee34b98fbfd13651"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a80b88cfa23474981cf70fc5d3a682057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aad0404234f12d4dc468c889698ef5486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="adac28cb6d0de6317e867c31942ccac65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a46c3ce7eb1fa4bba2e2d1602a325b779"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad67a6aa2952057b4966d77c183e52609"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a251f52d58c2858ba3ca9e24e7a77606b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad9c071bb9428f6d83357a90bc41791c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad60a8702f75da8e1240b95293d5d2337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="abc0e606efd43f079dfd21bb6e1e05f94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetCDF_1_1NcVarAtt.html">NcVarAtt</a> netCDF::NcVar::putAtt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcType.html">NcType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new variable attribute or if already exisiting replaces it. </p>
<p>If you are writing a <em>Fill_Value</em> attribute, and will tell the HDF5 layer to use the specified fill value for that variable. </p><dl class="section user"><dt></dt><dd>Although it's possible to create attributes of all types, text and double attributes are adequate for most purposes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of attribute. </td></tr>
    <tr><td class="paramname">type</td><td>The attribute type. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the attribute (number of Nctype repeats). </td></tr>
    <tr><td class="paramname">dataValues</td><td>Data Values to put into the new attribute. If the type of data values differs from the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable type, type conversion will occur. (However, no type conversion is carried out for variables using the user-defined data types: nc_Vlen, nc_Opaque, nc_Compound and nc_Enum.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classnetCDF_1_1NcVarAtt.html" title="Class represents a netCDF attribute local to a netCDF variable. ">NcVarAtt</a> object for this new <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c3206fa2a7b72b8b27912c74edda685"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. </p>
<p>It differs from the above function in what argument(s) it accepts. In addition, no data conversion is carried out. This means that the type of the data in memory must match the type of the variable. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00815">815</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a62e4048e2a354d95115602326591505a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00806">806</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad65d0ddf3203b7dbb8d1893c361bd29f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00698">698</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae86f7194de16cf6704be6b4b1d769871"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00707">707</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a61f5b11910f537b0bd08851a9841f10b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const signed char *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00716">716</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27424c55d400205a760836c8233c0661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00725">725</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a432ad4bde6d6761d56722ba4f1c5a81f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00734">734</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af7613aa992db773e277e064e706572ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00743">743</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a177cdb8312158dcb068b364b14fbf323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00752">752</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74fc130af91f1fdd2b32fcbe7eeb6a0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00761">761</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a50737a3446b65a914e373acd8c33e26a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00770">770</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa869f9966c60bdffac49bb4959aac7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00779">779</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adda5fbc1ce6b4f50d8428b0e1551feb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const unsigned long long *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00797">797</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0a867f4b3d378f01e79c0953fac35c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>dataValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the entire data into the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. </p>
<p>This is the simplest interface to use for writing a value in a scalar variable or whenever all the values of a multidimensional variable can all be written at once. The values to be written are associated with the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable by assuming that the last dimension of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable varies fastest in the C interface.</p>
<p>Take care when using the simplest forms of this interface with record variables when you don't specify how many records are to be written. If you try to write all the values of a record variable into a <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> file that has no record data yet (hence has 0 records), nothing will be written. Similarly, if you try to write all of a record variable but there are more records in the file than you assume, more data may be written to the file than you supply, which may result in a segmentation violation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataValues</td><td>The data values. The order in which the data will be written to the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable is with the last dimension of the specified variable varying fastest. If the type of data values differs from the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable type, type conversion will occur. (However, no type conversion is carried out for variables using the user-defined data types: nc_Vlen, nc_Opaque, nc_Compound and nc_Enum.) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00788">788</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16cb7c930fba5ebf4e726cbce491b16c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. </p>
<p>It differs from the above function in what argument(s) it accepts. In addition, no data conversion is carried out. This means that the type of the data in memory must match the type of the variable. </p>

</div>
</div>
<a class="anchor" id="ae312b5c2c5c76d889ec614d1b9f16651"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a7ca6ecbc32ddc0294e475e2742229239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a4e3b0044d879f96ea4fff07722e389f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a9cb318e6069e359ad80c4c458b6da32b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const signed char *&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aea02c1e72af2935656904e254bac8450"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a56a7836b7c69a3f4629154909b774fe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a41e8c1b9ebe55fa2e8a44689724c2b2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a9b9b27b1960baffb53fe2613110aadb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ae19b329255a4875428213e28133ebb63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="af4a497ca223b9b208ee0b721a5a13a77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac9635fc9f885ed2720af80469a2b1b18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a116d4113f7988571fb33e776cbb22cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long long&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a7b88daf90520bcc5b838d717638e0021"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>datumValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a single datum into the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Vector specifying the index where the data values will be written. The indices are relative to 0, so for example, the first data value of a two-dimensional variable would have index (0,0). The elements of index must correspond to the variable's dimensions. Hence, if the variable uses the unlimited dimension, the first index would correspond to the unlimited dimension.</td></tr>
    <tr><td class="paramname">datumValue</td><td>The data value. If the type of data values differs from the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable type, type conversion will occur. (However, no type conversion is carried out for variables using the user-defined data types: nc_Vlen, nc_Opaque, nc_Compound and nc_Enum.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac11b9a43ef0064e005055c1bea735f02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. </p>
<p>It differs from the above function in what argument(s) it accepts. In addition, no data conversion is carried out. This means that the type of the data in memory must match the type of the variable. </p>

</div>
</div>
<a class="anchor" id="ad540d036f57f72ecac5766fde0716044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a9cb15cdcd383bd90809fa04429d8ed2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac5457490c3a1e2613959a3b0e1e70d8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aeeb3f1a2322d943ea78d568199044413"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const signed char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a9efa486cafa05f28414a15376c8b260c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a21dcd0ef6fabb660078b5a5e01d4aceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ae385e9be2176b452484e933089e67316"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a76108f380c2dab5acb3bd80b37da856f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a763b0a2d6665ac22ab1be21b8b39c102"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a27c7a83399d39f19dc36b5eff7346d33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a0e71b8c076cc50a0df42ede288126f25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aa0e5f0d6c4a41d2eaebd53bac5bd12d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a85917e3d98ddefbe57f16b3aa001afc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an array of values into the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. </p>
<p>The portion of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable to write is specified by giving a corner and a vector of edge lengths that refer to an array section of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. The values to be written are associated with the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable by assuming that the last dimension of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable varies fastest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startp</td><td>Vector specifying the index where the first data values will be written. The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0). The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable, the first index corresponds to the starting record number for writing the data values.</td></tr>
    <tr><td class="paramname">countp</td><td>Vector specifying the number of indices selected along each dimension. To write a single value, for example, specify count as (1, 1, ... , 1). The elements of count correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.</td></tr>
    <tr><td class="paramname">dataValues</td><td>The data values. The order in which the data will be written to the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable is with the last dimension of the specified variable varying fastest. If the type of data values differs from the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable type, type conversion will occur. (However, no type conversion is carried out for variables using the user-defined data types: nc_Vlen, nc_Opaque, nc_Compound and nc_Enum.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5791a9465de08041995216f53e1f7c2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. </p>
<p>It differs from the above function in what argument(s) it accepts. In addition, no data conversion is carried out. This means that the type of the data in memory must match the type of the variable. </p>

</div>
</div>
<a class="anchor" id="a3127cd1a4bffd82345663dd9fa56c303"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a2cd689020652db39fe7e192945456ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad901b940d682607563c3841949d123e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a06a1df030c369c504bc3c89af1cf95de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const signed char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a2b6814394c25d2aa56dc4dabd6c60b54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a098349114f8007379eb2dacc1bac5fd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a0007e66fbbc9edc2225f861221809b6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="af8065c5284c5b0766762379ccb48183e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad979d641bc1287023a259eaf96e0c187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a1b063d6a941b2a868cdbe17cc927e577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aa51c0722f9a99befdc5a7467c059eea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a003c7c020ab5f00c6be72cc2d320c027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aa5847afc22338614a8885d7a8654ae11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an array of values into the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. </p>
<p>The subsampled array section is specified by giving a corner, a vector of counts, and a stride vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startp</td><td>Vector specifying the index where the first data values will be written. The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0). The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable, the first index corresponds to the starting record number for writing the data values.</td></tr>
    <tr><td class="paramname">countp</td><td>Vector specifying the number of indices selected along each dimension. To write a single value, for example, specify count as (1, 1, ... , 1). The elements of count correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.</td></tr>
    <tr><td class="paramname">stridep</td><td>A vector of ptrdiff_t integers that specifies the sampling interval along each dimension of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. The elements of the stride vector correspond, in order, to the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable's dimensions (stride[0] gives the sampling interval along the most slowly varying dimension of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable). Sampling intervals are specified in type-independent units of elements (a value of 1 selects consecutive elements of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable along the corresponding dimension, a value of 2 selects every other element, etc.). A NULL stride argument is treated as (1, 1, ... , 1).</td></tr>
    <tr><td class="paramname">dataValues</td><td>The data values. The order in which the data will be written to the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable is with the last dimension of the specified variable varying fastest. If the type of data values differs from the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable type, type conversion will occur. (However, no type conversion is carried out for variables using the user-defined data types: nc_Vlen, nc_Opaque, nc_Compound and nc_Enum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f4a231f4b9385ef346d4cebf869f13a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. </p>
<p>It differs from the above function in what argument(s) it accepts. In addition, no data conversion is carried out. This means that the type of the data in memory must match the type of the variable. </p>

</div>
</div>
<a class="anchor" id="ae5f24f65c150c12fc31fc1f066d8dee2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a6373ec61b53209f3246874d0839c8d52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="afdd16d9c72ea9e8c014e16f7961c09ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ab21606e1c6f31d7889b94070c37bb868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const signed char *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac978eb02324a9cbd0d3416c3a46574d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ab29fe35f6fb657c6f6fa883ad9c30cdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a348f092cf821bd14e123fb446eeec96a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a406d7e26e8e065f68ee35353b8172c89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a3c560b3ef22c84a16d06ed0be299d5a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a43d642dbf6b04d00c96bd414357981fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aed905a5afbaffe9f2ead0f6f1b9fd977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ae8983e6b481aa26725b40797f9ca6c13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ab8388b7c786eace3bbefadfcad5e10d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::putVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>startp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>countp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>stridep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ptrdiff_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>imapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>dataValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a mapped array section of values into the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. </p>
<p>The mapped array section is specified by giving a corner, a vector of counts, a stride vector, and an index mapping vector. The index mapping vector is a vector of integers that specifies the mapping between the dimensions of a <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable and the in-memory structure of the internal data array. No assumptions are made about the ordering or length of the dimensions of the data array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">countp</td><td>Vector specifying the number of indices selected along each dimension. To write a single value, for example, specify count as (1, 1, ... , 1). The elements of count correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.</td></tr>
    <tr><td class="paramname">stridep</td><td>A vector of ptrdiff_t integers that specifies the sampling interval along each dimension of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable. The elements of the stride vector correspond, in order, to the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable's dimensions (stride[0] gives the sampling interval along the most slowly varying dimension of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable). Sampling intervals are specified in type-independent units of elements (a value of 1 selects consecutive elements of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable along the corresponding dimension, a value of 2 selects every other element, etc.). A NULL stride argument is treated as (1, 1, ... , 1).</td></tr>
    <tr><td class="paramname">imap</td><td>Vector specifies the mapping between the dimensions of a <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable and the in-memory structure of the internal data array. The elements of the index mapping vector correspond, in order, to the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable's dimensions (imap[0] gives the distance between elements of the internal array corresponding to the most slowly varying dimension of the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable). Distances between elements are specified in type-independent units of elements (the distance between internal elements that occupy adjacent memory locations is 1 and not the element's byte-length as in <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> 2). A NULL argument means the memory-resident values have the same structure as the associated <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable.</td></tr>
    <tr><td class="paramname">dataValues</td><td>The data values. The order in which the data will be written to the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable is with the last dimension of the specified variable varying fastest. If the type of data values differs from the <a class="el" href="namespacenetCDF.html" title="C++ API for netCDF4. ">netCDF</a> variable type, type conversion will occur. (However, no type conversion is carried out for variables using the user-defined data types: nc_Vlen, nc_Opaque, nc_Compound and nc_Enum.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7962371f921a2003261c9156a8c10661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::rename </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename the variable. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00682">682</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92b89cc33bd3ab564c023e5620c0f4db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::setChecksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnetCDF_1_1NcVar.html#a6fa17911a9f7ec09cc05e34bc4f63a39">ChecksumMode</a>&#160;</td>
          <td class="paramname"><em>checksumMode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the checksum parameters of a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChecksumMode</td><td>Enumeration type. Allowable parameters are: "nc_NOCHECKSUM", "nc_FLETCHER32". </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00661">661</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02d0550ce2b4874e27e443467801d5b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::setChunking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnetCDF_1_1NcVar.html#a1e8425b2967665ab83f1e76abac2a76a">ChunkMode</a>&#160;</td>
          <td class="paramname"><em>chunkMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>chunksizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets chunking parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunkMode</td><td>Enumeration type. Allowable parameters are: "nc_CONTIGUOUS", "nc_CHUNKED" </td></tr>
    <tr><td class="paramname">chunksizes</td><td>Shape of chunking, used if ChunkMode=nc_CHUNKED. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00543">543</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69eb657938c93ce61c545625c338fa09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::setCompression </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableShuffleFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableDeflateFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deflateLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the compression parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enableShuffleFilter</td><td>Set to true to turn on shuffle filter. </td></tr>
    <tr><td class="paramname">enableDeflateFilter</td><td>Set to true to turn on deflate filter. </td></tr>
    <tr><td class="paramname">deflateLevel</td><td>The deflate level, must be 0 and 9. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00601">601</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a429f38087cc007c8d6f947e1b4fab41d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::setEndianness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnetCDF_1_1NcVar.html#ad6e882d6cc8aa698ef82b96e14eaa7a9">EndianMode</a>&#160;</td>
          <td class="paramname"><em>endianMode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the endianness of the variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Endianness</td><td>enumeration type. Allowable parameters are: "nc_ENDIAN_NATIVE" (the default), "nc_ENDIAN_LITTLE", "nc_ENDIAN_BIG" </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00637">637</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a148c942970df9692406406c674341ad7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::setFill </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fillValue</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00569">569</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae8817f6ab44699ca5e83acf97d6e2c61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NcVar::setFill </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>fillValue</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. </p>
<p>It differs from the above function in what argument(s) it accepts. The function can be used for any type, including user-defined types. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillMode</td><td>Setting to true, turns on fill mode. </td></tr>
    <tr><td class="paramname">fillValue</td><td>Pointer to fill value. Must be the same type as the variable. Ignored if fillMode=.false. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00578">578</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af911b1164ee5664b59740e6785661213"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void netCDF::NcVar::setFill </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>fillValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the fill parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillMode</td><td>Setting to true, turns on fill mode. </td></tr>
    <tr><td class="paramname">fillValue</td><td>Fill value for the variable. Must be the same type as the variable. Ignored if fillMode=.false. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ncVar_8h_source.html#l00291">291</a> of file <a class="el" href="ncVar_8h_source.html">ncVar.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aed6a3f330998706e012532a66ae4dd00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparator operator </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00014">14</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5193f5190c50d693489bb3fdbe36a08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetCDF_1_1NcVar.html">NcVar</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparator operator </p>

<p>Definition at line <a class="el" href="ncVar_8cpp_source.html#l00020">20</a> of file <a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ncVar_8h_source.html">ncVar.h</a></li>
<li><a class="el" href="ncVar_8cpp_source.html">ncVar.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="2"/>
<address style="text-align: center;">
<a href="http://www.unidata.ucar.edu/software/netcdf/">Return to the Main Unidata NetCDF page.</a><br>
<img src="http://www.unidata.ucar.edu/images/logos/uniLogo.png">
<address style="text-align: right;"><small>
Generated on Fri Nov 11 2016 15:28:29 for NetCDF-C++. NetCDF is
a <a href="http://www.unidata.ucar.edu/">Unidata</a> library.</small></address>
</body>
</html>
